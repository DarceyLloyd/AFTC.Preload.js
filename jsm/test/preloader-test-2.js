/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/aftc-modules/aftc-modules.js":
/*!***************************************************!*\
  !*** ./node_modules/aftc-modules/aftc-modules.js ***!
  \***************************************************/
/*! namespace exports */
/*! export AnimationFrameStack [provided] [unused] [could be renamed] */
/*! export EventManager [provided] [unused] [could be renamed] */
/*! export FPSMonitor [provided] [unused] [could be renamed] */
/*! export RGBToHex [provided] [unused] [could be renamed] */
/*! export RGBToHex2 [provided] [unused] [could be renamed] */
/*! export XHR [provided] [unused] [could be renamed] */
/*! export appendTo [provided] [unused] [could be renamed] */
/*! export argsToObject [provided] [used in preloader-test-2.js] [could be renamed] */
/*! export arrayClear [provided] [unused] [could be renamed] */
/*! export arrayContains [provided] [unused] [could be renamed] */
/*! export arrayEmpty [provided] [unused] [could be renamed] */
/*! export arrayGetMax [provided] [unused] [could be renamed] */
/*! export arrayGetMin [provided] [unused] [could be renamed] */
/*! export arrayMax [provided] [unused] [could be renamed] */
/*! export arrayMin [provided] [unused] [could be renamed] */
/*! export arrayRemoveIndex [provided] [unused] [could be renamed] */
/*! export arrayRemoveItem [provided] [unused] [could be renamed] */
/*! export arrayShuffle [provided] [unused] [could be renamed] */
/*! export arrayShuffle2 [provided] [unused] [could be renamed] */
/*! export attachDebug [provided] [unused] [could be renamed] */
/*! export boolToString [provided] [unused] [could be renamed] */
/*! export boolToYesNo [provided] [unused] [could be renamed] */
/*! export cutStringTo [provided] [unused] [could be renamed] */
/*! export debugTo [provided] [unused] [could be renamed] */
/*! export degToRad [provided] [unused] [could be renamed] */
/*! export escapeHTML [provided] [unused] [could be renamed] */
/*! export getAnchor [provided] [unused] [could be renamed] */
/*! export getBrowser [provided] [unused] [could be renamed] */
/*! export getBrowserX [provided] [unused] [could be renamed] */
/*! export getBrowserY [provided] [unused] [could be renamed] */
/*! export getCleanJSONString [provided] [unused] [could be renamed] */
/*! export getCookie [provided] [unused] [could be renamed] */
/*! export getDaysBetween [provided] [unused] [could be renamed] */
/*! export getElementOffsetTop [provided] [unused] [could be renamed] */
/*! export getElementPos [provided] [unused] [could be renamed] */
/*! export getElementPosition [provided] [unused] [could be renamed] */
/*! export getFileExtension [provided] [used in preloader-test-2.js] [could be renamed] */
/*! export getGUID [provided] [unused] [could be renamed] */
/*! export getIEVersion [provided] [unused] [could be renamed] */
/*! export getLastPartOfUrl [provided] [unused] [could be renamed] */
/*! export getMySQLDateTimeString [provided] [unused] [could be renamed] */
/*! export getOS [provided] [unused] [could be renamed] */
/*! export getRandomBoolean [provided] [unused] [could be renamed] */
/*! export getRandomFloat [provided] [unused] [could be renamed] */
/*! export getRandomInt [provided] [unused] [could be renamed] */
/*! export getRandomString [provided] [unused] [could be renamed] */
/*! export getRandomThatsNot [provided] [unused] [could be renamed] */
/*! export getRange [provided] [unused] [could be renamed] */
/*! export getStringBetween [provided] [unused] [could be renamed] */
/*! export getStringsBetween2 [provided] [unused] [could be renamed] */
/*! export getUID [provided] [unused] [could be renamed] */
/*! export getUKDate [provided] [unused] [could be renamed] */
/*! export getUSDate [provided] [unused] [could be renamed] */
/*! export getUkDateFromDbDateTime [provided] [unused] [could be renamed] */
/*! export getUkDateTimeFromDbDateTime [provided] [unused] [could be renamed] */
/*! export getWeightedRandom [provided] [unused] [could be renamed] */
/*! export getWordCount [provided] [unused] [could be renamed] */
/*! export getWordsFromString [provided] [unused] [could be renamed] */
/*! export hasClass [provided] [unused] [could be renamed] */
/*! export hexToRgb [provided] [unused] [could be renamed] */
/*! export inString [provided] [unused] [could be renamed] */
/*! export inertiaTo [provided] [unused] [could be renamed] */
/*! export isAlphaNumeric [provided] [unused] [could be renamed] */
/*! export isAndroid [provided] [unused] [could be renamed] */
/*! export isArray [provided] [unused] [could be renamed] */
/*! export isBool [provided] [unused] [could be renamed] */
/*! export isBoolean [provided] [unused] [could be renamed] */
/*! export isChrome [provided] [unused] [could be renamed] */
/*! export isDOM [provided] [unused] [could be renamed] */
/*! export isEdge [provided] [unused] [could be renamed] */
/*! export isElement [provided] [unused] [could be renamed] */
/*! export isElement2 [provided] [unused] [could be renamed] */
/*! export isEmail [provided] [unused] [could be renamed] */
/*! export isEven [provided] [unused] [could be renamed] */
/*! export isFireFox [provided] [unused] [could be renamed] */
/*! export isIE [provided] [unused] [could be renamed] */
/*! export isIOS [provided] [unused] [could be renamed] */
/*! export isInArray [provided] [unused] [could be renamed] */
/*! export isInString [provided] [unused] [could be renamed] */
/*! export isInViewport [provided] [unused] [could be renamed] */
/*! export isMobile [provided] [unused] [could be renamed] */
/*! export isNumber [provided] [unused] [could be renamed] */
/*! export isNumeric [provided] [unused] [could be renamed] */
/*! export isOdd [provided] [unused] [could be renamed] */
/*! export isOpera [provided] [unused] [could be renamed] */
/*! export isSafari [provided] [unused] [could be renamed] */
/*! export isStringInArray [provided] [unused] [could be renamed] */
/*! export lTrimBy [provided] [unused] [could be renamed] */
/*! export loadScript [provided] [unused] [could be renamed] */
/*! export log [provided] [used in preloader-test-2.js] [could be renamed] */
/*! export logTo [provided] [unused] [could be renamed] */
/*! export normaliseRange [provided] [unused] [could be renamed] */
/*! export numToHex [provided] [unused] [could be renamed] */
/*! export objectToObject [provided] [used in preloader-test-2.js] [could be renamed] */
/*! export onReady [provided] [unused] [could be renamed] */
/*! export parseArrayToFloat [provided] [unused] [could be renamed] */
/*! export parseArrayToInt [provided] [unused] [could be renamed] */
/*! export rTrimBy [provided] [unused] [could be renamed] */
/*! export radToDeg [provided] [unused] [could be renamed] */
/*! export regExReplaceAll [provided] [unused] [could be renamed] */
/*! export removeFileFromPath [provided] [unused] [could be renamed] */
/*! export replaceAll [provided] [unused] [could be renamed] */
/*! export replaceDoubleBackSlash [provided] [unused] [could be renamed] */
/*! export replaceDoubleForwardSlash [provided] [unused] [could be renamed] */
/*! export roundTo [provided] [unused] [could be renamed] */
/*! export setCookie [provided] [unused] [could be renamed] */
/*! export setHTML [provided] [used in preloader-test-2.js] [could be renamed] */
/*! export stringToBool [provided] [unused] [could be renamed] */
/*! export trimStringBy [provided] [unused] [could be renamed] */
/*! export ucFirst [provided] [unused] [could be renamed] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "argsToObject": () => /* binding */ argsToObject,
/* harmony export */   "objectToObject": () => /* binding */ objectToObject,
/* harmony export */   "log": () => /* binding */ log,
/* harmony export */   "setHTML": () => /* binding */ setHTML,
/* harmony export */   "getFileExtension": () => /* binding */ getFileExtension
/* harmony export */ });
/* unused harmony exports AnimationFrameStack, arrayClear, arrayContains, arrayEmpty, arrayGetMax, arrayGetMin, arrayMax, arrayMin, arrayRemoveIndex, arrayRemoveItem, arrayShuffle, arrayShuffle2, isInArray, isStringInArray, getBrowser, getBrowserX, getBrowserY, isInViewport, boolToString, boolToYesNo, degToRad, hexToRgb, numToHex, radToDeg, RGBToHex, RGBToHex2, stringToBool, getCookie, setCookie, getDaysBetween, getMySQLDateTimeString, getUKDate, getUkDateFromDbDateTime, getUkDateTimeFromDbDateTime, getUSDate, appendTo, attachDebug, debugTo, logTo, getIEVersion, getOS, isAndroid, isChrome, isEdge, isFireFox, isIE, isIOS, isMobile, isOpera, isSafari, getElementOffsetTop, hasClass, getElementPosition, getElementPos, isDOM, isElement, isElement2, EventManager, onReady, getWordsFromString, loadScript, XHR, getRandomBoolean, getRandomFloat, getRandomInt, getRandomThatsNot, getRange, getWeightedRandom, inertiaTo, isEven, isOdd, normaliseRange, parseArrayToFloat, parseArrayToInt, roundTo, FPSMonitor, getGUID, getUID, isAlphaNumeric, isArray, isBool, isBoolean, isNumber, isNumeric, cutStringTo, escapeHTML, getAnchor, getCleanJSONString, getLastPartOfUrl, getRandomString, getStringBetween, getStringsBetween2, getWordCount, inString, isInString, lTrimBy, regExReplaceAll, removeFileFromPath, replaceAll, replaceDoubleBackSlash, replaceDoubleForwardSlash, rTrimBy, trimStringBy, ucFirst, isEmail */
// aftc-modules v1.4.1
// Author: Darcey@aftc.io
function AnimationFrameStack() {
    var me = this;

    this.init = function(){
        if (!window){
            console.error("AnimationFrameStack(): ERROR - Unable to access window!");
        } else {
            if (!window.aftcAnimStack){
                window.aftcAnimStack = {
                    firstRun: true,
                    enabled: true,
                    stack: [],
                    uid: Math.floor(Math.random()*99999)
                }
            }
        }

        if (window.aftcAnimStack.firstRun){
            window.aftcAnimStack.firstRun = false;
            this.processFnStack();
        }
    }

    this.start = function(){
        window.aftcAnimStack.enabled = true;
        this.processFnStack();
    }

    this.stop = function(){
        window.aftcAnimStack.enabled = false;
    }

    this.dispose = function(){
        if (window.aftcAnimStack){
            window.aftcAnimStack.enabled = false;
            window.aftcAnimStack.stack = [];
            delete window.aftcAnimStack.stack;
        }
    }

    this.processFnStack = function(){
        if (!window.aftcAnimStack.enabled){ return; }

        for(let i=0; i < window.aftcAnimStack.stack.length; i++){
            window.aftcAnimStack.stack[i].fn();
        }

        window.requestAnimationFrame(me.processFnStack);
    }

    this.add = function(uid,fn){
        window.aftcAnimStack.stack.push({
            uid: uid,
            fn: fn
        });
    }

    this.remove = function(uid){
        for(let i=0; i < window.aftcAnimStack.stack.length; i++){
            if (window.aftcAnimStack.stack[i].uid === uid){
                // window.aftcAnimStack.stack = arrayRemoveItem(window.aftcAnimStack.stack,fn);
                window.aftcAnimStack.stack.splice(i,1);
            }
        }
    }

    this.init();
}

/**
 * @function: AnimationFrameStack()
 * @desc: Gives easy access to a single requestAnimationFrame loop which you can add functions to process in each loop, note the function stack is stored on global window scope
 * @method add: add a function to the stack to be executed on animationFrameLoop
 * @method remove: remove a function from the stack
 * @method start: start the requestAnimationFrame loop
 * @method stop: stop the requestAnimationFrame loop
 * @method dispose: dispose of all functions in the function stack
 * @link:
 */
function arrayClear(arr) {
    while (arr.length > 0) { arr.pop(); }
}

function arrayContains(needle, haystack) {
    if (haystack.indexOf(needle) > -1) { return true; } else { return false; }
}
function arrayEmpty(arr) {
    while (arr.length > 0) { arr.pop(); }
}
function arrayGetMax(arr) {
    return Math.max.apply(Math, arr);
}


function arrayGetMin(arr) {
    return Math.min.apply(Math, arr);
}
function arrayMax(arr) {
    return Math.max.apply(Math, arr);
}
function arrayMin(arr) {
    return Math.min.apply(Math, arr);
}
function arrayRemoveIndex(arr,index){
    arr.splice(index,1);
}

function arrayRemoveItem(arr, value) {
    return arr.filter(function(item){
        return item != value;
    });
}
function arrayShuffle(arr) {
    let currentIndex = arr.length,
        temporaryValue, randomIndex;

    // While there remain elements to shuffle...
    while (0 !== currentIndex) {

        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = arr[currentIndex];
        arr[currentIndex] = arr[randomIndex];
        arr[randomIndex] = temporaryValue;
    }

    return arr;
}

function arrayShuffle2(a) {
    let x, t, r = new Uint32Array(1);
    for (let i = 0, c = a.length - 1, m = a.length; i < c; i++ , m--) {
        crypto.getRandomValues(r);
        x = Math.floor(r / 65536 / 65536 * m) + i;
        t = a[i], a[i] = a[x], a[x] = t;
    }

    return a;
}
function isInArray(needle, haystack) {
    if (haystack.indexOf(needle) > -1) { return true; } else { return false; }
}
function isStringInArray(needle, haystack) {
    return (new RegExp('(' + haystack.join('|').replace(/\./g, '\\.') + ')$')).test(needle);
}

function getBrowser () {
    let ua = navigator.userAgent, tem, M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(M[1])) {
        tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE';
    }
    if (M[1] === 'Chrome') {
        tem = ua.match(/\bOPR\/(\d+)/);
        if (tem != null) {
            return 'Opera';
        }
    }
    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
    if ((tem = ua.match(/version\/(\d+)/i)) != null) {
        M.splice(1, 1, tem[1]);
    }
    return M[0];
}
function getBrowserX(){
    let supportPageOffset = window.pageXOffset !== undefined;
    let isCSS1Compat = ((document.compatMode || "") === "CSS1Compat");

    let x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;
    // let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

    return x;
}


function getBrowserY(){
    let supportPageOffset = window.pageXOffset !== undefined;
    let isCSS1Compat = ((document.compatMode || "") === "CSS1Compat");

    // let x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;
    let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

    return y;
}

function isInViewport(el){
    let top = el.offsetTop;
    let left = el.offsetLeft;
    let width = el.offsetWidth;
    let height = el.offsetHeight;

    while(el.offsetParent) {
        el = el.offsetParent;
        top += el.offsetTop;
        left += el.offsetLeft;
    }

    return (
        top < (window.pageYOffset + window.innerHeight) &&
        left < (window.pageXOffset + window.innerWidth) &&
        (top + height) > window.pageYOffset &&
        (left + width) > window.pageXOffset
    );


    // let bounding = ele.getBoundingClientRect();
    // return (
    //     bounding.top >= 0 &&
    //     bounding.left >= 0 &&
    //     bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    //     bounding.right <= (window.innerWidth || document.documentElement.clientWidth)
    // );
}

function argsToObject(fArgs, obj, strict) {
    if (fArgs[0] && typeof (fArgs[0]) === "object") {
        let args = fArgs[0];

        if (strict === undefined) {
            strict = true;
        }
        if (args && typeof (args) === "object") {
            for (let key in args) {
                if (strict) {
                    if (obj.hasOwnProperty(key)) {
                        obj[key] = args[key];
                    } else {
                        console.warn("argsToObject(): Argument [" + key + "] is not supported.");
                    }
                } else {
                    obj[key] = args[key];
                }
            }
        }

    }
};

/**
 * @function: argsToObject(fArgs, obj, strict)
 * @desc: Quick and easy args to object
 * @param args object: arguments (from the function structure, typically code will always be 'arguments'
 * @param obj object: object to parse into
 * @param strict boolean: console.warn any args that have been supplied that don't exist in args
 * @return: null
 * @alias: argsTo
 * @link: https://codepen.io/AllForTheCode/pen/PaqbKN
 */
function boolToString (bool) {

    if (!bool || bool === undefined || typeof (bool) != "boolean") {
        console.log("AFTC.js: getBoolToString(str): Error - input is not a boolean!");
        return "error";
    }

    if (bool) {
        return "true";
    } else {
        return "false";
    }
}
function boolToYesNo (b) {

    if (!b || b === undefined || typeof (b) != "boolean") {
        console.log("getYesNoFromBool(str): Error - input is not a boolean!");
        return "error";
    }

    if (b) {
        return "yes";
    } else {
        return "no";
    }
}
function degToRad(input) { return input * (Math.PI / 180); }
function hexToRgb (hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}
function numToHex (num) {
    return num.toString(16);
}
function objectToObject(src, dest, strict = true) {
    for (let key in src) {
        if (strict) {
            if (dest.hasOwnProperty(key)) {
                dest[key] = src[key];
            } else {
                console.warn("ObjectToObject(): Destination object key doesn't exist [" + key + "].");
            }
        } else {
            dest[key] = src[key];
        }
    }
}
function radToDeg(input) { return input * (180 / Math.PI); }
function RGBToHex (r, g, b) {
    return ((r << 16) | (g << 8) | b).toString(16);
}

function RGBToHex2 (r, g, b) {
    function getHex(c) {
        let hex = c.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    }
    let hex = "#" + getHex(r) + getHex(g) + getHex(b);
    hex = hex.toUpperCase();
    return hex;
}
function stringToBool (str) {

    if (!str || str === undefined || typeof (str) != "string") {
        console.log("StringToBool(str): Error - input string is not valid!");
        return false;
    }

    switch (str.toLowerCase()) {
        case "y":
            return true;
            break;
        case "yes":
            return true;
            break;
        case "1":
            return true;
            break;
        case "true":
            return true;
            break;
        default:
            return false;
            break;
    }
}


function getCookie(name) {
	//return .cookie(name);
	var keyValue = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|)');
	return keyValue ? keyValue[2] : null;
}
function setCookie(cname, cvalue, exdays) {
	// var expires = new Date();
	// expires.setTime(expires.getTime() + (1 * 24 * 60 * 60 * 1000));
	// document.cookie = name + '=' + value + ';expires=' + expires.toUTCString();
	var d = new Date();
	d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
	var expires = "expires=" + d.toUTCString();
	document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
}

// export function setCookie(name, value) {
// 	//document.cookie = name + "=" + value + "; expires=Thu, 18 Dec 2013 12:00:00 GMT";
// 	//.cookie(name, value, {expires:365,path:'/cookies'});
// 	var expires = new Date();
// 	expires.setTime(expires.getTime() + (1 * 24 * 60 * 60 * 1000));
// 	document.cookie = name + '=' + value + ';expires=' + expires.toUTCString();
// }
function getDaysBetween (startDateTime, endDateTime) {
    let msPerDay = 8.64e7;
    // Copy dates so don't mess them up
    let sd = new Date(startDateTime);
    let ed = new Date(endDateTime);
    // Set to noon - avoid DST errors
    sd.setHours(12, 0, 0);
    ed.setHours(12, 0, 0);
    // Round to remove daylight saving errors
    return Math.round((ed - sd) / msPerDay);
}

function getMySQLDateTimeString() {
    let now = new Date();
    let year = now.getFullYear();
    let month = now.getMonth() + 1;
    let day = now.getDate();
    let hour = now.getHours();
    let minute = now.getMinutes();
    let second = now.getSeconds();
    if (month.toString().length === 1) {
        month = '0' + month;
    }
    if (day.toString().length === 1) {
        day = '0' + day;
    }
    if (hour.toString().length === 1) {
        hour = '0' + hour;
    }
    if (minute.toString().length === 1) {
        minute = '0' + minute;
    }
    if (second.toString().length === 1) {
        second = '0' + second;
    }
    let str = year + '/' + month + '/' + day + ' ' + hour + ':' + minute + ':' + second;
    return str;
}

function getUKDate(dte){
    let output = dte.getDay() + "-" + (dte.getMonth()+1) + "-" + dte.getFullYear();
    return output;
}
function getUkDateFromDbDateTime (input) {
    // "2016-04-08 21:11:59" to UK date
    if (input === "" || input === null) {
        return "no input";
    }
    let DateTime = input.split(" ");
    let DateParts = DateTime[0].split("-");
    let UKDate = DateParts[2] + "/" + DateParts[1] + "/" + DateParts[0];
    return UKDate;
}
function getUkDateTimeFromDbDateTime  (input) {
    // "2016-04-08 21:11:59" to UK date time
    let DateTime = input.split(" ");
    let DateParts = DateTime[0].split("-");
    let TimeParts = DateTime[1].split(":");
    let UKDate = DateParts[2] + "/" + DateParts[1] + "/" + DateParts[0];
    let Time = TimeParts[0] + ":" + TimeParts[1];
    return (UKDate + " " + Time);
}
function getUSDate(dte){
    let output = dte.getFullYear() + "-" + (dte.getMonth()+1) + "-" + (dte.getDay()+1)
    return output;
}
function appendTo(elementOrId,msg,endOfLine="<br>"){
    // WARNING: IE11 Wont play nice even with webpack babel on defaults of args
    // WARNING: This will not be built for IE compatibility - please use aftc.js for that npm i aftc.js
    function isElement(o) {
        return (
            typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
                o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string"
        );
    }

    let ele = false;
    if (typeof(elementOrId) == "string"){
        elementOrId = elementOrId.replace("#","");
        ele = document.getElementById(elementOrId);
        if (!ele){
            console.error("AppendTo(): Unable to find ID '" + elementOrId + "' on the DOM!");
            return false;
        }
    } else {
        ele = elementOrId;
    }

    if (isElement(ele)){
        ele.innerHTML = ele.innerHTML + msg + endOfLine;

    } else {
        console.error("AppendTo(): Unable to log to element or id provided!");
        console.error(elementOrId);
        return false;
    }
}


function attachDebug(no,ele) {
    // return id's not the div create elements as these are type of object and not html element
    let ids = [];

    let debugContainer = document.createElement("div");
    debugContainer.id = "debug-container";
    debugContainer.style.zIndex = "999999";
    debugContainer.style.position = "fixed";
    debugContainer.style.right = "5px";
    debugContainer.style.top = "5px";
    debugContainer.style.textAlgin = "right";


    window.aftcDebug = [];

    for (let i = 0; i < no; i++) {
        let r = Math.round(Math.random()*9999999999);
        let id = "aftc-debug-container-" + r;
        let div = document.createElement("div");
        div.id = id;
        div.style.minWidth = "50px";
        // div.style.height = "20px";
        div.style.marginBottom = "3px";
        div.style.border = "1px dashed #999999";
        div.style.padding = "1px 2px 2px 4px";
        div.style.background = "RGBA(255,255,255,0.92)";
        div.style.color = "#000000";
        div.classList.add("debug-row");
        debugContainer.appendChild(div);
        div.addEventListener("click", function (e) {
            console.log(this.innerHTML);
        });

        window.aftcDebug.push(div);
        ids.push(id);
    }
    if (ele){
        ele.appendChild(debugContainer);
    } else {
        document.body.appendChild(debugContainer);
    }

    console.warn("AttachDebug(): Attached!");
    console.warn("AttachDebug(): Use DebugTo(index,string) to write directly to debug elements.");
    return ids;
}
function debugTo(index, str) {
    if (window.aftcDebug) {
        if (window.aftcDebug[index]) {
            window.aftcDebug[index].innerHTML = str;
        }
    }
}
function log(arg) {
    console.log(arg);
}

function logTo(elementOrId,msg,append=false,endOfLine=""){
    // WARNING: IE11 Wont play nice even with webpack babel on defaults of args
    // WARNING: This will not be built for IE compatibility - please use aftc.js for that npm i aftc.js

    function isElement(o) {
        return (
            typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
                o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string"
        );
    }

    let ele = false;
    if (typeof(elementOrId) == "string"){
        elementOrId = elementOrId.replace("#","");
        ele = document.getElementById(elementOrId);
        if (!ele){
            console.error("LogTo(): Unable to find ID '" + elementOrId + "' on the DOM!");
            return false;
        }
    } else {
        ele = elementOrId;
    }

    if (isElement(ele)){
        if (append === true){
            ele.innerHTML = ele.innerHTML + msg + endOfLine;
        } else {
            ele.innerHTML = msg + endOfLine;
        }

    } else {
        console.error("LogTo(): Unable to log to element or id provided!");
        console.error(elementOrId);
        return false;
    }
}


function getIEVersion () {
    let match = navigator.userAgent.match(/(?:MSIE |Trident\/.*; rv:)(\d+)/);
    return match ? parseInt(match[1]) : undefined;
}
function getOS(testAgent) {
    let userAgent;

    if (!testAgent){
        userAgent = navigator.userAgent || navigator.vendor || window.opera;
    } else {
        userAgent = testAgent;
    }

    userAgent = userAgent.toLowerCase();




    // Windows Phone must come first because its UA also contains "Android"!
    if (/windows phone/i.test(userAgent)) {
        return {
            os:"windows phone",
            userAgent:userAgent
        }
    }

    // Samsung Browser detection S8
    if (/samsungbrowser/i.test(userAgent)) {
        return {
            os:"android",
            userAgent:userAgent
        }
    }



    if (/android/i.test(userAgent)) {
        return {
            os:"android",
            userAgent:userAgent
        }
    }

    if (/ipad|iphone|ipod/i.test(userAgent)) {
        return {
            os:"ios",
            userAgent:userAgent
        }
    }



    // Windows Phone must come first because its UA also contains "Android"
    if (/win64|win32|win16|win95|win98|windows 2000|windows xp|msie|windows nt 6.3; trident|windows nt|windows/i.test(userAgent)) {
        return {
            os:"windows",
            userAgent:userAgent
        }
    }


    if (/os x/i.test(userAgent)) {
        return {
            os:"osx",
            userAgent:userAgent
        }
    }

    if (/macintosh|osx/i.test(userAgent)) {
        return {
            os:"osx",
            userAgent:userAgent
        }
    }

    if (/openbsd/i.test(userAgent)) {
        return {
            os:"open bsd",
            userAgent:userAgent
        }
    }


    if (/sunos/i.test(userAgent)) {
        return {
            os:"sunos",
            userAgent:userAgent
        }
    }






    if (/crkey/i.test(userAgent)) {
        return {
            os:"chromecast",
            userAgent:userAgent
        }
    }

    if (/appletv/i.test(userAgent)) {
        return {
            os:"apple tv",
            userAgent:userAgent
        }
    }

    if (/wiiu/i.test(userAgent)) {
        return {
            os:"nintendo wiiu",
            userAgent:userAgent
        }
    }

    if (/nintendo 3ds/i.test(userAgent)) {
        return {
            os:"nintendo 3ds",
            userAgent:userAgent
        }
    }

    if (/playstation/i.test(userAgent)) {
        return {
            os:"playstation",
            userAgent:userAgent
        }
    }

    if (/kindle/i.test(userAgent)) {
        return {
            os:"amazon kindle",
            userAgent:userAgent
        }
    }

    if (/ cros /i.test(userAgent)) {
        return {
            os:"chrome os",
            userAgent:userAgent
        }
    }



    if (/ubuntu/i.test(userAgent)) {
        return {
            os:"ubuntu",
            userAgent:userAgent
        }
    }


    if (/googlebot/i.test(userAgent)) {
        return {
            os:"google bot",
            userAgent:userAgent
        }
    }

    if (/bingbot/i.test(userAgent)) {
        return {
            os:"bing bot",
            userAgent:userAgent
        }
    }

    if (/yahoo! slurp/i.test(userAgent)) {
        return {
            os:"yahoo bot",
            userAgent:userAgent
        }
    }



    return {
        os: false,
        userAgent:userAgent
    };
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


function isAndroid(){
    let ua = navigator.userAgent.toLowerCase();
    if (/windows phone/i.test(ua)) {
        return false;
    } else {
        let isAndroid = ua.indexOf("android") > -1; //&& ua.indexOf("mobile");
        return isAndroid;
    }
}

function isChrome() {
    var isChromium = window.chrome;
    var winNav = window.navigator;
    var vendorName = winNav.vendor;
    var isOpera = typeof window.opr !== "undefined";
    var isIEedge = winNav.userAgent.indexOf("Edge") > -1;
    var isIOSChrome = winNav.userAgent.match("CriOS");

    if (isIOSChrome) {
        // is Google Chrome on IOS
        return true;
    } else if (
        isChromium !== null &&
        typeof isChromium !== "undefined" &&
        vendorName === "Google Inc." &&
        isOpera === false &&
        isIEedge === false
    ) {
        // is Google Chrome
        return true;
    } else {
        // not Google Chrome
        return false;
    }
}
function isEdge () {
    //let isEdge = !isIE && !!window.StyleMedia; // Edge 20+
    let edge = false;
    if (/Edge\/\d./i.test(navigator.userAgent)) {
        edge = true;
    }
    return edge;
}
function isFireFox () {
    // let is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    // return is_firefox;
    return (typeof InstallTrigger !== 'undefined');
}
function isIE () {
    // let is_ie = navigator.userAgent.toLowerCase().indexOf('MSIE') > -1;
    // return is_ie;
    // params.isIE = navigator.userAgent.match(/MSIE|Trident/);
    // params.isIE = document.documentMode; // IS9 and above
    return /*@cc_on!@*/ false || !!document.documentMode; // Internet Explorer 6-11
}

function isIOS() {
    let iDevices = [
        'iPad Simulator',
        'iPhone Simulator',
        'iPod Simulator',
        'iPad',
        'iPhone',
        'iPod'
    ];

    if (!!navigator.platform) {
        while (iDevices.length) {
            if (navigator.platform === iDevices.pop()){ return true; }
        }
    }

    return false;
}

function isMobile(){
    // Windows Phone must come first because its UA also contains "Android"!
    let ua = navigator.userAgent.toLowerCase();
    if (/windows phone/i.test(ua)) {
        return true;
    } else {
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            return true;
        } else {
            return false;
        }
    }
}
/**
 * @function: isMobile()
 * @desc: Detects if the device you are using is a mobile or not
 * @return boolean
 * @link: https://codepen.io/AllForTheCode/pen/KRbLdm
 */
function isOpera() {
    // let isChromium = window.chrome;
    // let isOpera = window.navigator.userAgent.indexOf("OPR") > -1 || window.navigator.userAgent.indexOf("Opera") > -1;
    // let isOpera = (navigator.userAgent.match(/Opera|OPR\//) ? true : false);
    let isOpera = (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    return isOpera;
}
function isSafari() {
    // let is_safari = navigator.userAgent.toLowerCase().indexOf('safari') > -1;
    // return is_safari;
    return /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || (typeof safari !== 'undefined' && safari.pushNotification));
}
function getElementOffsetTop(elementId) {
    let element = getElementById(elementId);
    let curtop = 0;
    if (element.hasOwnProperty("offsetParent")){
        do {
            curtop += element.offsetTop;
        } while (element = element.offsetParent);
        return parseFloat([curtop]);
    } else {
        return false;
    }
}
function hasClass(elementOrId, c) {
    if (isElement(elementOrId)) {
        return elementOrId.classList.contains(c);
    } else {
        return getElementById(elementOrId).classList.contains(c);
    }
}
function setHTML(elementOrId, str, mode = "set") {
    let ele;
    if (typeof (elementOrId) === "string") {
        ele = document.getElementById(elementOrId);
        if (!ele) {
            ele = document.querySelector(elementOrId);
        }
    } else {
        ele = elementOrId;
    }

    if (ele) {

        switch (mode) {
            case "append":
                ele.innerHTML += str + "<br>";
                break;
            case "prepend":
                ele.innerHTML = str + "<br>" + ele.innerHTML;
                break;
            default:
                ele.innerHTML = str;
                break;
        }

     

    } else {
        return "setHTML(elementOrId, str): Usage error: Unable to retrieve element id or use element [" + elementOrId + "]";
    }
}
function getElementPosition(el) {
    let position = {
        top: el.offsetTop,
        left: el.offsetLeft
    };

    if (el.offsetParent) {
        let parentPosition = {
            top: el.offsetParent.offsetTop,
            left: el.offsetParent.offsetLeft
        };

        position.top += parentPosition.top;
        position.left += parentPosition.left;
    }
    return position;
}

function getElementPos(el) {
    let x = 0;
    let y = 0;
    while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
        x += el.offsetLeft - el.scrollLeft;
        y += el.offsetTop - el.scrollTop;
        el = el.offsetParent;
    }
    return { left: x, top: y };
}
function isDOM(obj) {
    // this works for newer browsers
    try { return obj instanceof HTMLElement; }

        // this works for older browsers
    catch (e) {
        return (typeof obj === "object") &&
            (obj.nodeType === 1) && (typeof obj.style === "object") &&
            (typeof obj.ownerDocument === "object");
    }
};
function isElement(o) {
    let answer = (
        typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
            o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string"
    );

    if (answer != true) {
        return false;
    } else {
        return true;
    }
}
function isElement2(element) {
    // works on major browsers back to IE7
    return element instanceof Element;
}

class EventManager {
    // WARNING: export class will not work for transpile to IE11 (DELETE CLASS IF YOU STILL NEED aftc-modules or use SRC file includes)
    // NOTE: Alternatively use aftc.js for ES5 - npm i aftc.js
}

/** jso {
 * "Function": "EventManager.js",
 * "Description": "A centralised event stack where you can hook your functions / class's into for centralised quick and easy event application event handling.",
 * "Methods": [
 *      {
 *          "name": "list",
 *          "description": "Lists which events have been created and available for dispatch in the EventManager.",
  *          "returns": "console.log",
 *      },
 *      {
 *          "name": "add",
 *          "description": "Adds or creates a new event within the event manager and attached a callback function / listener object to be called on dispatch of this event.",
 *          "parameters": [
 *              {
 *                  "name": "eventName",
 *                  "required": "true",
 *                  "description": "The name of the event to add.",
 *              },
 *              {
 *                  "name": "callbackFunction",
  *                  "required": "true",
 *                  "description": "The listener object / function which gets called when the event is triggered.",
 *              },
 *          ],
 *      },
 *      {
 *          "name": "dispatch",
 *          "description": "Dispatches / Triggers an event by name from the EventManager.",
 *          "parameters": [
 *              {
 *                  "name": "eventName",
 *                  "required": "true",
 *                  "description": "The name of the event to dispatch.",
 *              }
 *          ],
 *      },
 *  ]
 * }
 */
function onReady(fn) {
    // IE9+
    if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
        setTimeout(fn, 10);
    } else {
        if (document.addEventListener) {
            document.addEventListener("DOMContentLoaded", function(){
                window.setTimeout(fn, 10);
            });
        }

    }
}

function getWordsFromString(str, maxWords) {
    let wordCount = str.split(/\S+/).length - 1;
    let re = new RegExp("^\\s*\\S+(?:\\s+\\S+){0," + (maxWords - 1) + "}");
    let output = "";
    if (wordCount >= maxWords) {
        output = str.match(re);
    } else {
        output = str;
    }
    return { output: output, remaining: (maxWords - wordCount) };
}

function loadScript(src, onComplete, onProgress){
    let head = document.getElementsByTagName("head")[0] || document.body;

    if (!head){
        console.error("loadScript(): Unable to get DOM Head or DOM Body!");
        return;
    }

    let script = document.createElement("script");

    let xhr = new XMLHttpRequest();

    // report progress events
    xhr.addEventListener("progress", function(event) {
        if (event.lengthComputable) {
            var percentComplete = event.loaded / event.total;
            // console.log(percentComplete);
            if (onProgress){
                onProgress(percentComplete);
            }
        } else {
            // Unable to compute progress information since the total size is unknown
            if (onProgress){
                onProgress(false);
            }
        }
    }, false);

    // load responseText into a new script element
    xhr.addEventListener("load", function(e) {
        script.innerHTML = e.target.responseText;
        document.documentElement.appendChild(script);

        if (onComplete) {
            onComplete();
        }

        // script.addEventListener("load", function() {
        //     // this runs after the new script has been executed...
        // });
    }, false);

    xhr.open("GET", src);
    xhr.send();
}
class XHR {
    // WARNING: export class will not work for transpile to IE11 (DELETE CLASS IF YOU STILL NEED aftc-modules or use SRC file includes)
    // NOTE: Alternatively use aftc.js for ES5 - npm i aftc.js (new XHR())


    constructor() {
        //https://javascript.info/xmlhttprequest

        // var defs
        this.args = {
            url: false,
            method: false,
            data: false,
            dataType: false, // aka requestType this is either form or json xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');
            responseType: false, // for clientside processing response data type
            timeout: 0,
            onComplete: false,
            onError: false, // only triggers if the request couldn't be made at all
            onProgress: false,
            onCancel: false,
            username: false,
            password: false
        };

        this.url = false;
        this.urlParams = "";
        this.xhr = false;

        // Process arguments
        if (arguments[0] && typeof (arguments[0]) === "object") {
            for (let key in arguments[0]) {
                if (this.args.hasOwnProperty(key)) {
                    this.args[key] = arguments[0][key];
                }
            }
        }
        // console.log(this.args);

        // Validate
        let valid = true;

        if (this.args.url === false) {
            let msg = `XHR(): Usage error: Option "url" has not been set!
Please enter a valid url to make a request to!`;
            console.error(msg);
            valid = false;
            return false;
        }

        if (this.args.method === false) {
            let msg = `XHR(): Usage error: Option "method" has not been set!
Valid options are:
    POST,
    GET`;
            console.error(msg);
            valid = false;
            return false;
        }




        // log(this.args);
        let showDataTypeError = false;
        if (this.args.data !== false){
            if (this.args.dataType === false){
                showDataTypeError = true;
            } else {
                if (typeof(this.args.dataType) == "string"){
                    if (
                        this.args.dataType.toLowerCase() !== "json" &&
                        this.args.dataType.toLowerCase() !== "form" &&
                        this.args.dataType.toLowerCase() !== "text"){
                            showDataTypeError = true;
                    }
                }
            }
        }


        if (showDataTypeError) {
            let msg = `XHR(): Usage error: Invalid "dataType" has been set!
Valid options are:
    JSON        - send json string
    FORM        - send form object
    TEXT        - send url string
`;
            console.error(msg);
            valid = false;
            return false;
        }





        let showResponseTypeError = false;
        if (this.args.responseType === false){
            showResponseTypeError = true;
        } else {
            if (typeof(this.args.dataType) == "string"){
                if (
                    this.args.responseType.toLowerCase() != "text" &&
                    this.args.responseType.toLowerCase() != "document" &&
                    this.args.responseType.toLowerCase() != "json" &&
                    this.args.responseType.toLowerCase() != "arraybuffer" &&
                    this.args.responseType.toLowerCase() != "blob"){
                        showResponseTypeError = true;
                }
            }
        }



        if (showResponseTypeError) {
            let msg =
                `XHR(): Usage warning: Option "responseType" not set!
Valid options are:
    json \t\t\t JSON (parsed automatically)
    document \t\t XML Document (XPath etc),
    text \t\t\t string,
    arraybuffer \t ArrayBuffer for binary data,
    blob \t\t\t Blob for binary data,
`;
            console.error(msg);
            valid = false;
            return false;
        }






        if (this.args.onComplete === false) {
            let msg = `XHR(): Usage error: Option "onComplete" has not been set!
Your making a request but are not doing anything with the response? Make sure to supply an onComplete callback function.`;
            console.error(msg);
            valid = false;
            return false;
        }



        if (valid) {
            this.makeRequest();
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



    makeRequest() {
        this.xhr = new XMLHttpRequest();

        this.xhr.timeout = this.args.timeout;


        // GET
        // Append data variables to url string, only handle json, form and string

        // POST||PUT||DELETE||PATCH
        // If json send json object
        // If form send form object
        // If text send string

        if (this.args.method.toLowerCase() == "get") {
            // GET
            if (this.args.dataType !== false) {
                switch (this.args.dataType.toLowerCase()) {
                    case "text":
                        this.url = this.args.url + "?" + this.args.data;
                        break;
                    case "form":
                        this.url = this.args.url + "?";
                        for (var key of this.args.data.keys()) {
                            let v = this.args.data.get(key);
                            // console.log(v);
                            this.url = this.url + encodeURI(key) + "=" + encodeURI(v) + "&";
                        }
                        break;
                    case "json":
                        this.url = this.args.url + "?";
                        for (let key in this.args.data) {
                            // console.log(key);
                            // console.log(this.args.data[key]);
                            let v = this.args.data[key];
                            // log(key);
                            this.url = this.url + encodeURI(key) + "=" + encodeURI(v) + "&";
                        }
                        break;
                }
                // console.log("this.url = " + this.url);
            } else {
                this.url = this.args.url
            }
        } else {
            // POST || PUT || PATCH || DELETE
            this.url = this.args.url
        }





        // open
        if (this.args.username !== false && this.args.password !== false) {
            this.xhr.open(this.args.method, this.url, this.args.username, this.args.password);
        } else {
            this.xhr.open(this.args.method, this.url);
        }

        // responseType
        this.xhr.responseType = this.args.responseType;




        // Set requestHeader type aka dataType and send
        if (this.args.dataType !== false && typeof(this.args.dataType) == "string") {
            switch (this.args.dataType.toLowerCase()) {
                case "json":
                    this.xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');
                    this.xhr.send(JSON.stringify(this.args.data));
                    break;
                case "form":
                    // for (var key of this.args.data.keys()) {
                    //     let v = this.args.data.get(key);
                    //     console.log(key + " = " + v);
                    // }
                    this.xhr.send(this.args.data);
                    break;
                case "text":
                    this.xhr.setRequestHeader("content-type", "application/x-www-form-urlencoded");
                    this.xhr.send(this.args.data);
                    break;
                default:
                    this.xhr.send();
                    break;
            }
        } else {
            this.xhr.send();
        }


        // Send
        // if (this.args.data !== false && this.args.dataType !== false){
        //     log("sending data");
        //     this.xhr.send(this.args.data);
        // } else {
        //     this.xhr.send();
        // }



        // Event Listeners
        this.xhr.addEventListener("progress", (e) => this.progressHandler(e), true);
        this.xhr.addEventListener("load", (e) => this.onLoadHandler(e), true);
        this.xhr.addEventListener("error", (e) => this.errorHandler(e), true);
        this.xhr.addEventListener("abort", (e) => this.errorHandler(e), true);
        this.xhr.addEventListener("timeout", (e) => this.errorHandler(e), true);
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


    errorHandler(e) {
        // console.log("XHR.errorHandler()");
        this.removeEventListeners();
        if (this.args.onError) {
            this.args.onError(e);
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


    progressHandler(e) {
        // console.log("XHR.progressHandler()");
        // if (e.lengthComputable) {
        //     console.log(`Received ${e.loaded} of ${e.total} bytes`);
        // } else {
        //     console.log(`Received ${e.loaded} bytes`); // no Content-Length
        // }
        // console.log(`Received ${event.loaded} of ${event.total}`);
        if (this.args.onProgress) {
            this.args.onProgress(e);
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


    onLoadHandler(e) {
        // console.log("XHR.onLoadHandler()");
        // console.log(`Done, got ${this.xhr.response.length} bytes`);
        // console.log(this.xhr.response);
        this.removeEventListeners();

        if (this.args.onComplete) {
            this.args.onComplete(e);
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


    getResponseHeader(name) {
        if (this.xhr) {
            return this.xhr.getResponseHeader(name);
        } else {
            return null;
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


    getAllResponseHeaders() {
        if (this.xhr) {
            return this.xhr.getAllResponseHeaders();
        } else {
            return null;
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


    getResponse() {
        if (this.xhr) {
            return this.xhr.response;
        } else {
            return null;
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


    removeEventListeners() {
        this.xhr.removeEventListener("progress", (e) => this.progressHandler(e));
        this.xhr.removeEventListener("load", (e) => this.onLoadHandler(e));
        this.xhr.removeEventListener("error", (e) => this.errorHandler(e));
        this.xhr.removeEventListener("abort", (e) => this.errorHandler(e));
        this.xhr.removeEventListener("timeout", (e) => this.errorHandler(e));
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}
function getRandomBoolean(){
    return Math.random() >= 0.5;
}
function getRandomFloat(min, max) {
    // let r = from + (Math.random()* (to*2));
    return (Math.random() * (max - min) + min);
};

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function getRandomThatsNot(min,max,not){
    let r = not; let lim = 100; let runs = 0;
    while (r===not && runs < lim){
        runs++;
        r = getRandomInt(min,max);
    }
    if (runs>=lim){
        return false;
    } else {
        return r;
    }
}
/**
 * @function: getRandomThatsNot(min,max,not)
 * @desc: returns a random int betwen your specified min and max values but never the not value
 * @param min number: the minimum your random number is allowed to go
 * @param max number: the maximum your random number is allowed to go
 * @alias: getRandom
 * @link: https://codepen.io/AllForTheCode/pen/yEBZNq
 */
function getRange(a,b){
    return Math.max(a, b) - Math.min(a, b);
}
function getWeightedRandom(odds, iterations) {
    if (!odds) {
        odds = [
            0.68, // 0
            0.69, // 1
            0.698, // 2
            0.6909, // 3
            0.68, // 4
            0.58, // 5
            0.57, // 6
            0.56, // 7
            0.4, // 8
            0.3, // 9
        ];
    }
    let weights = [];
    let r = 0;
    let iMax = 0;
    let wMax = 0;

    for (let i in odds) {
        if (!weights[i]) {
            weights[i] = 0;
        }

        for (let x = 0; x < iterations; x++) {
            r = Math.random();
            //log(r.toFixed(3) + "   " + odds[i].toFixed(3));
            if (r <= odds[i]) {
                weights[i] += odds[i];
            }
        }

        if (weights[i] > wMax) {
            wMax = weights[i];
            iMax = i;
        }
    }

    //log(weights);
    //log("wMax = " + wMax + "   iMax = " + iMax);
    return iMax;
};
/**
 * @function: getWeightedRandom(odds, iterations)
 * @desc: Get a weighted random based on odds and iterations
 * @param odds array: array of odds
 * @param iterations number: number of iterations to run on each number test
 * @link: https://codepen.io/AllForTheCode/pen/RyvWjZ
 */
function inertiaTo(current,target,amount){
    if (amount == 1) {
        return target;
    }
    let distToGo = target - current;
    let delta = current + (distToGo * amount);

    if (Math.abs(distToGo) < 0.01) {
        distToGo = 0;
        delta = target;
    }
    return delta;
}

function isEven(n) {
    return n % 2 === 0;
}

function isOdd(n) {
    return Math.abs(n % 2) === 1;
}
function normaliseRange(min, max, v) {
    let range = max - min;
    let step = 1 / range;
    let r = (step * (v - min));
    if (v < min) {
        r = 0;
    } else if (v > max) {
        r = 1;
    }
    return r;
}

function parseArrayToFloat(arr) {
    let converted;
    for (let i = 0; i < arr.length; i++) {
        converted = parseFloat(arr[i]);
        if (isNaN(converted)){
            arr[i] = 0;
        } else {
            arr[i] = converted;
        }
    }
    return arr;
}

function parseArrayToInt(arr) {
    let converted;
    for (let i = 0; i < arr.length; i++) {
        converted = parseInt(arr[i]);
        if (isNaN(converted)){
            arr[i] = 0;
        } else {
            arr[i] = converted;
        }
    }
    return arr;
}
function roundTo(v, dec) {
    return +(Math.round(Number(v + "e+" + dec)) + "e-" + dec);
}

class FPSMonitor {
    // WARNING: export class will not work for transpile to IE11 (DELETE CLASS IF YOU STILL NEED aftc-modules or use SRC file includes)
    // NOTE: Alternatively use aftc.js for ES5 - npm i aftc.js

    constructor(ele) {

        this.dom = {
            fps: false
        }

        this.fpsStack = false;
        this.stackSize = 60;
        this.index = 0;

        this.last = 0;
        this.now = 0;

        this.delta = 0;

        this.currentFrameFps = 0;

        this.total = 0;
        this.averageFps = 0;

        this.i = 0;

        if (ele){
            this.dom.fps = ele;
        }

        this.fpsStack = new Float32Array(this.stackSize);

        this.update();
    }




    update(){
        this.now = performance.now();

        this.delta = (this.now - this.last) / 1000;
        this.currentFrameFps = 1/this.delta;
        // log("currentFrameFps = " + this.currentFrameFps);

        this.fpsStack[this.index] = this.currentFrameFps;

        this.total = 0;
        for(this.i=0; this.i < this.stackSize; this.i++){
            this.total += this.fpsStack[this.i];
        }

        this.averageFps = Math.round( this.total/this.stackSize );

        if (this.dom.fps){
            this.dom.fps.innerText = this.averageFps;
        }

        this.last = this.now;

        this.index++;
        if (this.index >= this.stackSize){
            this.index = 0;
        }

        requestAnimationFrame(()=>{
            this.update();
        });
    }


    getFps(){
        return this.averageFps;
    }
}

function getGUID() {
    function Amiga() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }

    return Amiga() + Amiga() + '-' + Amiga() + '-' + Amiga() + '-' +
        Amiga() + '-' + Amiga() + Amiga() + Amiga();
}
function getUID(len) {
    if (len > 34){
        console.error("getUID(length): Limit error: Length must be 34 or lower");
    } else {
        return Math.random().toString(36).substr(2, len);
    }
}
function isAlphaNumeric(v) {
    return !(/\W/.test(v));
}
function isArray(input) {
    return !!input && input.constructor === Array;
    //return arr.constructor === Array;
}
function isBool(input) {
    if (typeof (input) === "boolean") {
        return true;
    } else {
        return false;
    }
}
function isBoolean(input) {
    if (typeof (input) === "boolean") {
        return true;
    } else {
        return false;
    }
}
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function cutStringTo(s, len) {
    return s.substring(0, len);
}
function escapeHTML(str) {
    if (typeof (str) != "string") { console.error("escape(arg): usage error: arg needs to be a string!"); return false; }

    let replacements = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "\"": "&quot;",
        "`": "&#039;"
    };
    return str.replace(/[<>&"]/g, function (character) {
        return replacements[character];
    });
}
function getAnchor(url) {
    if (!url) { url = window.location.href; }
    let anchorAvailable = isInString("#", url);
    if (anchorAvailable) {
        return url.slice(url.lastIndexOf('#') + 1);
    } else {
        return false;
    }
}
/**
 * @function: GetAnchor(url)
 * @desc: Get anchor from url
 * @param string url: The url to get the anchor from
 * @link:
 */
function getCleanJSONString (s) {
    // preserve newlines, etc - use valid JSON
    s = s.replace(/\\n/g, "\\n")
        .replace(/\\'/g, "\\'")
        .replace(/\\"/g, '\\"')
        .replace(/\\&/g, "\\&")
        .replace(/\\r/g, "\\r")
        .replace(/\\t/g, "\\t")
        .replace(/\\b/g, "\\b")
        .replace(/\\f/g, "\\f");
    // remove non-printable and other non-valid JSON chars
    s = s.replace(/[\u0000-\u0019]+/g, "");
    return s;
}
function getFileExtension(input) {
    return input.slice((input.lastIndexOf(".") - 1 >>> 0) + 2);
    // return (input.match(/(?:.+..+[^\/]+$)/ig) != null) ? input.split('.').slice(-1) : 'null';

}
function getLastPartOfUrl(url) {
    if (!url) {
        url = window.location.href;
    }
    let part = url.substring(url.lastIndexOf('/') + 1);
    return part;
}
function getRandomString(len) {
    let text = "";
    let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    for (let i = 0; i < len; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }

    return text;
}

function getStringBetween(str, start, end) {
    return str.split(start).pop().split(end).shift().trim();
}
/**
 * @function: getStringBetween(input,start,end)
 * @desc: Gets a string between two other strings
 * @param string input: input string to check
 * @param string start: start string marker
 * @param string end: end string marker
 * @link: https://codepen.io/AllForTheCode/pen/xxxxxxx
 */
function getStringsBetween2(str, start, end) {
    let orig = str;
    let results = [];
    // log(orig);
    // log("--------");

    function getBetween() {
        // log("CHECKING: " + str);
        let startMatchIndex = str.indexOf(start); // Find start match
        // log("startMatchIndex: " + startMatchIndex);
        if (startMatchIndex === -1) { return false; }

        let startCutIndex = start.length + startMatchIndex; // calc start cut index
        // log("startCutIndex: " + startCutIndex);

        str = str.substring(startCutIndex, str.length); // LTrim to start cut index
        // log("CUT: " + str);

        let endMatchIndex = str.indexOf(end); // find end match index
        // log("endMatchIndex: " + endMatchIndex);
        if (endMatchIndex === -1) { return false; }

        let between = str.substring(0, endMatchIndex); // get string between
        // log("between: " + between);
        let endCutIndex = end.length + endMatchIndex;
        //log("endCutIndex: " + endCutIndex);
        str = str.substring(endCutIndex, str.length); // cut off end string
        //log("FINAL: " + str);
        return between;
    }
    let lim = 500; // Want to loop forever? 500 seems like areasonable limit
    let pos = 0;
    let result = true;
    while (pos <= lim && result != false) {
        pos++;
        result = getBetween();
        if (result) {
            //log("between["+i+"] = " + result);
            results.push(result);
            //log("");
        }
    }
    return results;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**
 * @function: getStringsBetween(str,start,end)
 * @desc: Gets all strings between two other strings (multi match)
 * @param string str: input string to check
 * @param string start: start string marker
 * @param string end: end string marker
 * @link: https://codepen.io/AllForTheCode/pen/xxxxxxx
 */
function getWordCount(str) {
    return str.split(/\S+/).length - 1;
}
function inString(find,source) { return source.indexOf(find) !== -1; }
function isInString(find,source) { return source.indexOf(find) !== -1; }
function lTrimBy(str, by) {
    return str.substring(by, str.length);
}
function regExReplaceAll(haystack, needle, rep) {
    const special = ["-", "[", "]", "/", "{", "}", "(", ")", "*", "+", "?", ".", "\\", "^", "$", "|"];
    if (needle.length == 1) {
        if (isInArray(needle, special)) {
            needle = "\\" + needle;
        }
    }
    const searchRegExp = new RegExp(needle, 'g');
    return haystack.replace(searchRegExp, rep);

}
function removeFileFromPath(path) {
    //let pa = '/this/is/a/folder/aFile.txt';
    let r = /[^\/]*$/;
    path = path.replace(r, '');
    return path;
}
function replaceAll(haystack,needle,replace){
    return haystack.split(needle).join(replace);
}
function replaceDoubleBackSlash(str,rep){
    return str.replace(/\\\\/g, rep); // replaces all occurances of \\ with rep
}
function replaceDoubleForwardSlash(str,rep){
    return str.replace(/\/\//g, rep); // replaces all occurances of // with rep
}
function rTrimBy(str, trimBy) {
    return (str.substring(0, str.length - trimBy));
}
function trimStringBy(str, trimBy) {
    return (str.substring(0, str.length - trimBy));
}
function ucFirst(s) {
    if (typeof s !== 'string') return ''
    return s.charAt(0).toUpperCase() + s.slice(1)
}
function isEmail (email) {
    let re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(email);
}


/***/ }),

/***/ "./aftc.preloader.js":
/*!***************************!*\
  !*** ./aftc.preloader.js ***!
  \***************************/
/*! namespace exports */
/*! export AFTCPreloader [provided] [used in preloader-test-2.js] [could be renamed] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AFTCPreloader": () => /* binding */ AFTCPreloader
/* harmony export */ });
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/aftc-modules/aftc-modules.js */ "./node_modules/aftc-modules/aftc-modules.js");
;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


class AFTCPreloader {
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  constructor() {
    _defineProperty(this, "ItemVo", function () {
      this.id = false;
      this.src = false;
      this.ext = false;
      this.loaded = false;
      this.loading = false;
      this.autoAttach = true;
    });

    _defineProperty(this, "XHRLoader", function (parent, threadIndex, queueIndex, src) {
      // log("XHRLoader(parent, threadIndex, queueIndex, src)");
      this.parent = parent;
      this.threadIndex = threadIndex;
      this.queueIndex = queueIndex;
      this.src = src;
      this.xhr = new XMLHttpRequest();

      this.xhr.onload = e => {
        this.onLoadHandler(e);
      }; // this.xhr.addEventListener("progress", () => this.updateHandler, false);
      // this.xhr.addEventListener("load", transferComplete);
      // this.xhr.addEventListener("error", transferFailed);
      // this.xhr.addEventListener("abort", transferCanceled);
      // Detect abort, load, or error using the loadend event
      // this.xhr.addEventListener("loadend", () => this.loadEndHandler, false);


      this.xhr.open('GET', this.src, true);
      this.xhr.send();

      this.updateHandler = function (e) {}; // - - - - - - - - - - -


      this.onLoadHandler = function (e) {
        // log("XHRLoader.onLoadHandler(): " + this.src);
        this.parent.onFileLoaded(this.threadIndex, this.queueIndex);
        this.xhr = null;
      }; // - - - - - - - - - - -

    });

    (0,_node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__.log)("AFTCPreloader()");
    this.onProgressHandler = "";
    this.onCompleteHandler = "";
    this.queue = [];
    this.noOfFilesToLoad = 0;
    this.json = false;
    this.noOfThreads = 3;
    this.thread = []; // [0] > [noOfThreads] = "available" || "filled"

    this.queueCompleted = false;
    this.timer = false;
    (0,_node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__.argsToObject)(arguments, this, true);
    this.head = document.getElementsByTagName('head')[0] || document.body;
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


  help() {
    let msg = "";
    msg += "AFTCPreloader.help()" + "\n";
    msg += "JSON: [ {src:path,autoAttach=true} ]" + "\n";
    msg += "autoAttach is optional, defaults to true, only works for css and js file extensions" + "\n";
    (0,_node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__.log)(msg);
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


  add(id, src, autoAttach = true) {
    // log("AFTCPreloader.add(id,src,autoAttach=true)");
    let entry = this.ItemVo();
    entry.id = id;
    entry.src = src;
    entry.autoAttach = autoAttach;
    this.queue.push(entry);
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


  start(jsonPath) {
    (0,_node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__.log)("AFTCPreloader.start()"); // init

    for (let i = 0; i < this.noOfThreads; i++) {
      this.thread[i] = "available";
    }

    if (jsonPath) {
      // Using JSON file to add files to the queue
      this.loadConfig(jsonPath);
    } else {
      // Using add() to add files to the queue
      this.noOfFilesToLoad = this.queue.length;
      this.processThreadPool();
    }
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


  loadConfig(path) {
    // log("AFTCPreloader.loadConfig(path:" + path + ")");
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path, true);

    xhr.onreadystatechange = e => {
      if (xhr.readyState == 4 && xhr.status == 200) {
        this.json = JSON.parse(xhr.responseText); // log(this.json);

        this.json.forEach(jsonEntry => {
          let vo = new this.ItemVo();
          new _node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__.objectToObject(jsonEntry, vo, false);
          vo.ext = (0,_node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__.getFileExtension)(vo.src);
          this.queue.push(vo);
        }); // log(this.queue);

        this.noOfFilesToLoad = this.queue.length;
        this.processThreadPool();
      }
    };

    xhr.send();
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    


  processThreadPool() {
    // log("AFTCPreloader.processThreadPool()");
    let activeThreads = 0;

    for (let threadIndex = 0; threadIndex < this.noOfThreads; threadIndex++) {
      if (this.thread[threadIndex] === "available") {
        // Destructure
        let queueIndex, itemVo;
        [queueIndex, itemVo] = this.getNext(); // log(itemVo);

        if (itemVo !== false) {
          // log("\n#### Thread ["+ threadIndex + "] -------");
          // log("threadIndex: " + threadIndex + "   queueIndex: " + queueIndex);
          // log(itemVo);
          this.thread[threadIndex] = "filled";
          itemVo.loading = true;
          new this.XHRLoader(this, threadIndex, queueIndex, itemVo.src);
          activeThreads++;
        }
      }
    } // If all threads are inactive then we are done


    let preloaderComplete = true;

    for (let i = 0; i < this.noOfThreads; i++) {
      if (this.thread[i] !== "available") {
        preloaderComplete = false;
      }
    }

    if (preloaderComplete) {
      (0,_node_modules_aftc_modules_aftc_modules_js__WEBPACK_IMPORTED_MODULE_1__.log)("AFTCPreloader(): Complete!");

      if (this.onCompleteHandler) {
        this.onCompleteHandler();
      }
    }
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


  onFileLoaded(threadIndex, queueIndex) {
    // log("AFTCPreloader.onFileLoaded(threadIndex:"+threadIndex+",queueIndex:"+queueIndex+")");
    let vo = this.queue[queueIndex];
    vo.loading = false;
    vo.loaded = true;
    this.thread[threadIndex] = "available"; // Handle attach to dom

    if (this.queue[queueIndex].autoAttach === true) {
      if (vo.ext == "js") {
        // Attach JS to DOM
        let script = document.createElement('script'); // script.onload = ()=> {
        //     console.log("Script attached to DOM: " + vo.src);
        // }

        script.src = vo.src;
        document.head.appendChild(script);
      } else if (vo.ext == "css") {
        // Attach CSS to DOM
        let link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = vo.src;
        link.media = 'all';
        this.head.appendChild(link);
      }
    }

    if (this.onProgressHandler) {
      let percent = 0;
      let noOfFilesLoaded = 0;
      this.queue.forEach(vo => {
        if (vo.loaded) {
          noOfFilesLoaded++;
        }
      });
      percent = Math.round(100 / this.noOfFilesToLoad * noOfFilesLoaded);
      this.onProgressHandler(percent, this.queue[queueIndex].src);
    }

    this.processThreadPool();
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


  getNext() {
    let queueIndex = -1;
    let itemVo = false;

    for (let i = 0; i < this.queue.length; i++) {
      let entry = this.queue[i];

      if (entry.loaded === false && entry.loading === false) {
        queueIndex = i;
        itemVo = entry;
        break;
      }
    }

    return [queueIndex, itemVo];
  } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


}

/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__.g, __webpack_require__.* */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! default exports */
/*! export f [provided] [used in preloader-test-2.js] [usage prevents renaming] */
/*! other exports [not provided] [maybe used in preloader-test-2.js (runtime-defined)] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! default exports */
/*! export f [provided] [used in preloader-test-2.js] [usage prevents renaming] */
/*! other exports [not provided] [maybe used in preloader-test-2.js (runtime-defined)] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! default exports */
/*! export f [provided] [maybe used in preloader-test-2.js (runtime-defined)] [usage prevents renaming] */
/*! other exports [not provided] [maybe used in preloader-test-2.js (runtime-defined)] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! default exports */
/*! export f [provided] [maybe used in preloader-test-2.js (runtime-defined)] [usage prevents renaming] */
/*! other exports [not provided] [maybe used in preloader-test-2.js (runtime-defined)] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! default exports */
/*! export f [provided] [maybe used in preloader-test-2.js (runtime-defined)] [usage prevents renaming] */
/*! other exports [not provided] [maybe used in preloader-test-2.js (runtime-defined)] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global;


/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.7.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__ */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/************************************************************************/
(() => {
"use strict";
/*!*********************************!*\
  !*** ./src/preloader-test-2.js ***!
  \*********************************/
/*! namespace exports */
/*! runtime requirements: __webpack_require__ */
/* harmony import */ var aftc_modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aftc-modules */ "./node_modules/aftc-modules/aftc-modules.js");
/* harmony import */ var _aftc_preloader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../aftc.preloader */ "./aftc.preloader.js");
;

const preloader = new _aftc_preloader__WEBPACK_IMPORTED_MODULE_1__.AFTCPreloader({
  onProgressHandler: onProgressHandler,
  onCompleteHandler: onCompleteHandler
});
preloader.help();
preloader.start("./preloader.json");

function onProgressHandler(p, file) {
  (0,aftc_modules__WEBPACK_IMPORTED_MODULE_0__.setHTML)("status", "Loading");
  (0,aftc_modules__WEBPACK_IMPORTED_MODULE_0__.setHTML)("percent", p + "%");
  (0,aftc_modules__WEBPACK_IMPORTED_MODULE_0__.setHTML)("files", file, "prepend"); // log("onProgressHandler(p:" + p + ")");
}

function onCompleteHandler() {
  (0,aftc_modules__WEBPACK_IMPORTED_MODULE_0__.setHTML)("status", "Loaded"); // log("onCompleteHandler()");
}
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvYWZ0Yy1tb2R1bGVzL2FmdGMtbW9kdWxlcy5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9hZnRjLnByZWxvYWRlci5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9hZnRjLnByZWxvYWQuanMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2FmdGMucHJlbG9hZC5qcy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vYWZ0Yy5wcmVsb2FkLmpzLy4vc3JjL3ByZWxvYWRlci10ZXN0LTIuanMiXSwibmFtZXMiOlsiQUZUQ1ByZWxvYWRlciIsImNvbnN0cnVjdG9yIiwiaWQiLCJzcmMiLCJleHQiLCJsb2FkZWQiLCJsb2FkaW5nIiwiYXV0b0F0dGFjaCIsInBhcmVudCIsInRocmVhZEluZGV4IiwicXVldWVJbmRleCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib25sb2FkIiwiZSIsIm9uTG9hZEhhbmRsZXIiLCJvcGVuIiwic2VuZCIsInVwZGF0ZUhhbmRsZXIiLCJvbkZpbGVMb2FkZWQiLCJsb2ciLCJvblByb2dyZXNzSGFuZGxlciIsIm9uQ29tcGxldGVIYW5kbGVyIiwicXVldWUiLCJub09mRmlsZXNUb0xvYWQiLCJqc29uIiwibm9PZlRocmVhZHMiLCJ0aHJlYWQiLCJxdWV1ZUNvbXBsZXRlZCIsInRpbWVyIiwiYXJnc1RvT2JqZWN0IiwiYXJndW1lbnRzIiwiaGVhZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJib2R5IiwiaGVscCIsIm1zZyIsImFkZCIsImVudHJ5IiwiSXRlbVZvIiwicHVzaCIsInN0YXJ0IiwianNvblBhdGgiLCJpIiwibG9hZENvbmZpZyIsImxlbmd0aCIsInByb2Nlc3NUaHJlYWRQb29sIiwicGF0aCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJKU09OIiwicGFyc2UiLCJyZXNwb25zZVRleHQiLCJmb3JFYWNoIiwianNvbkVudHJ5Iiwidm8iLCJvYmplY3RUb09iamVjdCIsImdldEZpbGVFeHRlbnNpb24iLCJhY3RpdmVUaHJlYWRzIiwiaXRlbVZvIiwiZ2V0TmV4dCIsIlhIUkxvYWRlciIsInByZWxvYWRlckNvbXBsZXRlIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwibGluayIsInJlbCIsInR5cGUiLCJocmVmIiwibWVkaWEiLCJwZXJjZW50Iiwibm9PZkZpbGVzTG9hZGVkIiwiTWF0aCIsInJvdW5kIiwicHJlbG9hZGVyIiwicCIsImZpbGUiLCJzZXRIVE1MIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxRQUFROztBQUVuRCxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLG9CQUFvQix1Q0FBdUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QixXQUFXO0FBQ3ZDOztBQUVPO0FBQ1Asd0NBQXdDLGFBQWEsRUFBRSxPQUFPLGNBQWM7QUFDNUU7QUFDTztBQUNQLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ087QUFDUDtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1Asd0NBQXdDLGFBQWEsRUFBRSxPQUFPLGNBQWM7QUFDNUU7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR087QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsZ0NBQWdDO0FBQzFEO0FBQ1AsOEJBQThCLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBLDJDQUEyQyxvQkFBb0IsS0FBSztBQUNwRTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0MsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsdUJBQXVCLE1BQUssNEJBQTRCO0FBQ3hEOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EscUVBQXFFLDZEQUE2RCxFQUFFO0FBQ3BJO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxTQUFTLG1DQUFtQzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUN6QjBELHVEQUFPLENBQUMsUUFBRCxFQUFVLFFBQVYsQ0FBUCxDQUR5QixDQUV6QjtBQUNILEMiLCJmaWxlIjoicHJlbG9hZGVyLXRlc3QtMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGFmdGMtbW9kdWxlcyB2MS40LjFcbi8vIEF1dGhvcjogRGFyY2V5QGFmdGMuaW9cbmV4cG9ydCBmdW5jdGlvbiBBbmltYXRpb25GcmFtZVN0YWNrKCkge1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmICghd2luZG93KXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkFuaW1hdGlvbkZyYW1lU3RhY2soKTogRVJST1IgLSBVbmFibGUgdG8gYWNjZXNzIHdpbmRvdyFcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuYWZ0Y0FuaW1TdGFjayl7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWZ0Y0FuaW1TdGFjayA9IHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJ1bjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo5OTk5OSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHdpbmRvdy5hZnRjQW5pbVN0YWNrLmZpcnN0UnVuKXtcclxuICAgICAgICAgICAgd2luZG93LmFmdGNBbmltU3RhY2suZmlyc3RSdW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRm5TdGFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB3aW5kb3cuYWZ0Y0FuaW1TdGFjay5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NGblN0YWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB3aW5kb3cuYWZ0Y0FuaW1TdGFjay5lbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBpZiAod2luZG93LmFmdGNBbmltU3RhY2spe1xyXG4gICAgICAgICAgICB3aW5kb3cuYWZ0Y0FuaW1TdGFjay5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZnRjQW5pbVN0YWNrLnN0YWNrID0gW107XHJcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuYWZ0Y0FuaW1TdGFjay5zdGFjaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wcm9jZXNzRm5TdGFjayA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYgKCF3aW5kb3cuYWZ0Y0FuaW1TdGFjay5lbmFibGVkKXsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGZvcihsZXQgaT0wOyBpIDwgd2luZG93LmFmdGNBbmltU3RhY2suc3RhY2subGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICB3aW5kb3cuYWZ0Y0FuaW1TdGFjay5zdGFja1tpXS5mbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtZS5wcm9jZXNzRm5TdGFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbih1aWQsZm4pe1xyXG4gICAgICAgIHdpbmRvdy5hZnRjQW5pbVN0YWNrLnN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICB1aWQ6IHVpZCxcclxuICAgICAgICAgICAgZm46IGZuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbih1aWQpe1xyXG4gICAgICAgIGZvcihsZXQgaT0wOyBpIDwgd2luZG93LmFmdGNBbmltU3RhY2suc3RhY2subGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmFmdGNBbmltU3RhY2suc3RhY2tbaV0udWlkID09PSB1aWQpe1xyXG4gICAgICAgICAgICAgICAgLy8gd2luZG93LmFmdGNBbmltU3RhY2suc3RhY2sgPSBhcnJheVJlbW92ZUl0ZW0od2luZG93LmFmdGNBbmltU3RhY2suc3RhY2ssZm4pO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFmdGNBbmltU3RhY2suc3RhY2suc3BsaWNlKGksMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb246IEFuaW1hdGlvbkZyYW1lU3RhY2soKVxyXG4gKiBAZGVzYzogR2l2ZXMgZWFzeSBhY2Nlc3MgdG8gYSBzaW5nbGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3Agd2hpY2ggeW91IGNhbiBhZGQgZnVuY3Rpb25zIHRvIHByb2Nlc3MgaW4gZWFjaCBsb29wLCBub3RlIHRoZSBmdW5jdGlvbiBzdGFjayBpcyBzdG9yZWQgb24gZ2xvYmFsIHdpbmRvdyBzY29wZVxyXG4gKiBAbWV0aG9kIGFkZDogYWRkIGEgZnVuY3Rpb24gdG8gdGhlIHN0YWNrIHRvIGJlIGV4ZWN1dGVkIG9uIGFuaW1hdGlvbkZyYW1lTG9vcFxyXG4gKiBAbWV0aG9kIHJlbW92ZTogcmVtb3ZlIGEgZnVuY3Rpb24gZnJvbSB0aGUgc3RhY2tcclxuICogQG1ldGhvZCBzdGFydDogc3RhcnQgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBsb29wXHJcbiAqIEBtZXRob2Qgc3RvcDogc3RvcCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3BcclxuICogQG1ldGhvZCBkaXNwb3NlOiBkaXNwb3NlIG9mIGFsbCBmdW5jdGlvbnMgaW4gdGhlIGZ1bmN0aW9uIHN0YWNrXHJcbiAqIEBsaW5rOlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUNsZWFyKGFycikge1xyXG4gICAgd2hpbGUgKGFyci5sZW5ndGggPiAwKSB7IGFyci5wb3AoKTsgfVxyXG59XHJcblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5Q29udGFpbnMobmVlZGxlLCBoYXlzdGFjaykge1xyXG4gICAgaWYgKGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+IC0xKSB7IHJldHVybiB0cnVlOyB9IGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cclxufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5RW1wdHkoYXJyKSB7XHJcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHsgYXJyLnBvcCgpOyB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUdldE1heChhcnIpIHtcclxuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcnIpO1xyXG59XHJcblxyXG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUdldE1pbihhcnIpIHtcclxuICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcnIpO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlNYXgoYXJyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJyKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5TWluKGFycikge1xyXG4gICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFycik7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVJlbW92ZUluZGV4KGFycixpbmRleCl7XHJcbiAgICBhcnIuc3BsaWNlKGluZGV4LDEpO1xyXG59XHJcblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5UmVtb3ZlSXRlbShhcnIsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPSB2YWx1ZTtcclxuICAgIH0pO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycikge1xyXG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IGFyci5sZW5ndGgsXHJcbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUsIHJhbmRvbUluZGV4O1xyXG5cclxuICAgIC8vIFdoaWxlIHRoZXJlIHJlbWFpbiBlbGVtZW50cyB0byBzaHVmZmxlLi4uXHJcbiAgICB3aGlsZSAoMCAhPT0gY3VycmVudEluZGV4KSB7XHJcblxyXG4gICAgICAgIC8vIFBpY2sgYSByZW1haW5pbmcgZWxlbWVudC4uLlxyXG4gICAgICAgIHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KTtcclxuICAgICAgICBjdXJyZW50SW5kZXggLT0gMTtcclxuXHJcbiAgICAgICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gICAgICAgIHRlbXBvcmFyeVZhbHVlID0gYXJyW2N1cnJlbnRJbmRleF07XHJcbiAgICAgICAgYXJyW2N1cnJlbnRJbmRleF0gPSBhcnJbcmFuZG9tSW5kZXhdO1xyXG4gICAgICAgIGFycltyYW5kb21JbmRleF0gPSB0ZW1wb3JhcnlWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyO1xyXG59XHJcblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5U2h1ZmZsZTIoYSkge1xyXG4gICAgbGV0IHgsIHQsIHIgPSBuZXcgVWludDMyQXJyYXkoMSk7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgYyA9IGEubGVuZ3RoIC0gMSwgbSA9IGEubGVuZ3RoOyBpIDwgYzsgaSsrICwgbS0tKSB7XHJcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyKTtcclxuICAgICAgICB4ID0gTWF0aC5mbG9vcihyIC8gNjU1MzYgLyA2NTUzNiAqIG0pICsgaTtcclxuICAgICAgICB0ID0gYVtpXSwgYVtpXSA9IGFbeF0sIGFbeF0gPSB0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgaGF5c3RhY2spIHtcclxuICAgIGlmIChoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPiAtMSkgeyByZXR1cm4gdHJ1ZTsgfSBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ0luQXJyYXkobmVlZGxlLCBoYXlzdGFjaykge1xyXG4gICAgcmV0dXJuIChuZXcgUmVnRXhwKCcoJyArIGhheXN0YWNrLmpvaW4oJ3wnKS5yZXBsYWNlKC9cXC4vZywgJ1xcXFwuJykgKyAnKSQnKSkudGVzdChuZWVkbGUpO1xyXG59XHJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJyb3dzZXIgKCkge1xyXG4gICAgbGV0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCwgdGVtLCBNID0gdWEubWF0Y2goLyhvcGVyYXxjaHJvbWV8c2FmYXJpfGZpcmVmb3h8bXNpZXx0cmlkZW50KD89XFwvKSlcXC8/XFxzKihcXGQrKS9pKSB8fCBbXTtcclxuICAgIGlmICgvdHJpZGVudC9pLnRlc3QoTVsxXSkpIHtcclxuICAgICAgICB0ZW0gPSAvXFxicnZbIDpdKyhcXGQrKS9nLmV4ZWModWEpIHx8IFtdO1xyXG4gICAgICAgIHJldHVybiAnSUUnO1xyXG4gICAgfVxyXG4gICAgaWYgKE1bMV0gPT09ICdDaHJvbWUnKSB7XHJcbiAgICAgICAgdGVtID0gdWEubWF0Y2goL1xcYk9QUlxcLyhcXGQrKS8pO1xyXG4gICAgICAgIGlmICh0ZW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ09wZXJhJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBNID0gTVsyXSA/IFtNWzFdLCBNWzJdXSA6IFtuYXZpZ2F0b3IuYXBwTmFtZSwgbmF2aWdhdG9yLmFwcFZlcnNpb24sICctPyddO1xyXG4gICAgaWYgKCh0ZW0gPSB1YS5tYXRjaCgvdmVyc2lvblxcLyhcXGQrKS9pKSkgIT0gbnVsbCkge1xyXG4gICAgICAgIE0uc3BsaWNlKDEsIDEsIHRlbVsxXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTVswXTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEJyb3dzZXJYKCl7XHJcbiAgICBsZXQgc3VwcG9ydFBhZ2VPZmZzZXQgPSB3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZDtcclxuICAgIGxldCBpc0NTUzFDb21wYXQgPSAoKGRvY3VtZW50LmNvbXBhdE1vZGUgfHwgXCJcIikgPT09IFwiQ1NTMUNvbXBhdFwiKTtcclxuXHJcbiAgICBsZXQgeCA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XHJcbiAgICAvLyBsZXQgeSA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xyXG5cclxuICAgIHJldHVybiB4O1xyXG59XHJcblxyXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCcm93c2VyWSgpe1xyXG4gICAgbGV0IHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICBsZXQgaXNDU1MxQ29tcGF0ID0gKChkb2N1bWVudC5jb21wYXRNb2RlIHx8IFwiXCIpID09PSBcIkNTUzFDb21wYXRcIik7XHJcblxyXG4gICAgLy8gbGV0IHggPSBzdXBwb3J0UGFnZU9mZnNldCA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IGlzQ1NTMUNvbXBhdCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xyXG4gICAgbGV0IHkgPSBzdXBwb3J0UGFnZU9mZnNldCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IGlzQ1NTMUNvbXBhdCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcclxuXHJcbiAgICByZXR1cm4geTtcclxufVxyXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luVmlld3BvcnQoZWwpe1xyXG4gICAgbGV0IHRvcCA9IGVsLm9mZnNldFRvcDtcclxuICAgIGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcclxuICAgIGxldCB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xyXG4gICAgbGV0IGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICB3aGlsZShlbC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcclxuICAgICAgICB0b3AgKz0gZWwub2Zmc2V0VG9wO1xyXG4gICAgICAgIGxlZnQgKz0gZWwub2Zmc2V0TGVmdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHRvcCA8ICh3aW5kb3cucGFnZVlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHQpICYmXHJcbiAgICAgICAgbGVmdCA8ICh3aW5kb3cucGFnZVhPZmZzZXQgKyB3aW5kb3cuaW5uZXJXaWR0aCkgJiZcclxuICAgICAgICAodG9wICsgaGVpZ2h0KSA+IHdpbmRvdy5wYWdlWU9mZnNldCAmJlxyXG4gICAgICAgIChsZWZ0ICsgd2lkdGgpID4gd2luZG93LnBhZ2VYT2Zmc2V0XHJcbiAgICApO1xyXG5cclxuXHJcbiAgICAvLyBsZXQgYm91bmRpbmcgPSBlbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAvLyByZXR1cm4gKFxyXG4gICAgLy8gICAgIGJvdW5kaW5nLnRvcCA+PSAwICYmXHJcbiAgICAvLyAgICAgYm91bmRpbmcubGVmdCA+PSAwICYmXHJcbiAgICAvLyAgICAgYm91bmRpbmcuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiZcclxuICAgIC8vICAgICBib3VuZGluZy5yaWdodCA8PSAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKVxyXG4gICAgLy8gKTtcclxufVxyXG5cbmV4cG9ydCBmdW5jdGlvbiBhcmdzVG9PYmplY3QoZkFyZ3MsIG9iaiwgc3RyaWN0KSB7XHJcbiAgICBpZiAoZkFyZ3NbMF0gJiYgdHlwZW9mIChmQXJnc1swXSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBsZXQgYXJncyA9IGZBcmdzWzBdO1xyXG5cclxuICAgICAgICBpZiAoc3RyaWN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyZ3MgJiYgdHlwZW9mIChhcmdzKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gYXJncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGFyZ3Nba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJhcmdzVG9PYmplY3QoKTogQXJndW1lbnQgW1wiICsga2V5ICsgXCJdIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBhcmdzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbjogYXJnc1RvT2JqZWN0KGZBcmdzLCBvYmosIHN0cmljdClcclxuICogQGRlc2M6IFF1aWNrIGFuZCBlYXN5IGFyZ3MgdG8gb2JqZWN0XHJcbiAqIEBwYXJhbSBhcmdzIG9iamVjdDogYXJndW1lbnRzIChmcm9tIHRoZSBmdW5jdGlvbiBzdHJ1Y3R1cmUsIHR5cGljYWxseSBjb2RlIHdpbGwgYWx3YXlzIGJlICdhcmd1bWVudHMnXHJcbiAqIEBwYXJhbSBvYmogb2JqZWN0OiBvYmplY3QgdG8gcGFyc2UgaW50b1xyXG4gKiBAcGFyYW0gc3RyaWN0IGJvb2xlYW46IGNvbnNvbGUud2FybiBhbnkgYXJncyB0aGF0IGhhdmUgYmVlbiBzdXBwbGllZCB0aGF0IGRvbid0IGV4aXN0IGluIGFyZ3NcclxuICogQHJldHVybjogbnVsbFxyXG4gKiBAYWxpYXM6IGFyZ3NUb1xyXG4gKiBAbGluazogaHR0cHM6Ly9jb2RlcGVuLmlvL0FsbEZvclRoZUNvZGUvcGVuL1BhcWJLTlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib29sVG9TdHJpbmcgKGJvb2wpIHtcclxuXHJcbiAgICBpZiAoIWJvb2wgfHwgYm9vbCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiAoYm9vbCkgIT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkFGVEMuanM6IGdldEJvb2xUb1N0cmluZyhzdHIpOiBFcnJvciAtIGlucHV0IGlzIG5vdCBhIGJvb2xlYW4hXCIpO1xyXG4gICAgICAgIHJldHVybiBcImVycm9yXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJvb2wpIHtcclxuICAgICAgICByZXR1cm4gXCJ0cnVlXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcImZhbHNlXCI7XHJcbiAgICB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBib29sVG9ZZXNObyAoYikge1xyXG5cclxuICAgIGlmICghYiB8fCBiID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIChiKSAhPSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0WWVzTm9Gcm9tQm9vbChzdHIpOiBFcnJvciAtIGlucHV0IGlzIG5vdCBhIGJvb2xlYW4hXCIpO1xyXG4gICAgICAgIHJldHVybiBcImVycm9yXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGIpIHtcclxuICAgICAgICByZXR1cm4gXCJ5ZXNcIjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwibm9cIjtcclxuICAgIH1cclxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZ1RvUmFkKGlucHV0KSB7IHJldHVybiBpbnB1dCAqIChNYXRoLlBJIC8gMTgwKTsgfVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUmdiIChoZXgpIHtcclxuICAgIGxldCByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcclxuICAgIHJldHVybiByZXN1bHQgPyB7XHJcbiAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXHJcbiAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXHJcbiAgICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNilcclxuICAgIH0gOiBudWxsO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gbnVtVG9IZXggKG51bSkge1xyXG4gICAgcmV0dXJuIG51bS50b1N0cmluZygxNik7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RUb09iamVjdChzcmMsIGRlc3QsIHN0cmljdCA9IHRydWUpIHtcclxuICAgIGZvciAobGV0IGtleSBpbiBzcmMpIHtcclxuICAgICAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChkZXN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiT2JqZWN0VG9PYmplY3QoKTogRGVzdGluYXRpb24gb2JqZWN0IGtleSBkb2Vzbid0IGV4aXN0IFtcIiArIGtleSArIFwiXS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiByYWRUb0RlZyhpbnB1dCkgeyByZXR1cm4gaW5wdXQgKiAoMTgwIC8gTWF0aC5QSSk7IH1cbmV4cG9ydCBmdW5jdGlvbiBSR0JUb0hleCAociwgZywgYikge1xyXG4gICAgcmV0dXJuICgociA8PCAxNikgfCAoZyA8PCA4KSB8IGIpLnRvU3RyaW5nKDE2KTtcclxufVxyXG5cbmV4cG9ydCBmdW5jdGlvbiBSR0JUb0hleDIgKHIsIGcsIGIpIHtcclxuICAgIGZ1bmN0aW9uIGdldEhleChjKSB7XHJcbiAgICAgICAgbGV0IGhleCA9IGMudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gXCIwXCIgKyBoZXggOiBoZXg7XHJcbiAgICB9XHJcbiAgICBsZXQgaGV4ID0gXCIjXCIgKyBnZXRIZXgocikgKyBnZXRIZXgoZykgKyBnZXRIZXgoYik7XHJcbiAgICBoZXggPSBoZXgudG9VcHBlckNhc2UoKTtcclxuICAgIHJldHVybiBoZXg7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0Jvb2wgKHN0cikge1xyXG5cclxuICAgIGlmICghc3RyIHx8IHN0ciA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiAoc3RyKSAhPSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTdHJpbmdUb0Jvb2woc3RyKTogRXJyb3IgLSBpbnB1dCBzdHJpbmcgaXMgbm90IHZhbGlkIVwiKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChzdHIudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgIGNhc2UgXCJ5XCI6XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwieWVzXCI6XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiMVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInRydWVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn1cclxuXHJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvb2tpZShuYW1lKSB7XHJcblx0Ly9yZXR1cm4gLmNvb2tpZShuYW1lKTtcclxuXHR2YXIga2V5VmFsdWUgPSBkb2N1bWVudC5jb29raWUubWF0Y2goJyhefDspID8nICsgbmFtZSArICc9KFteO10qKSg7fCknKTtcclxuXHRyZXR1cm4ga2V5VmFsdWUgPyBrZXlWYWx1ZVsyXSA6IG51bGw7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb29raWUoY25hbWUsIGN2YWx1ZSwgZXhkYXlzKSB7XHJcblx0Ly8gdmFyIGV4cGlyZXMgPSBuZXcgRGF0ZSgpO1xyXG5cdC8vIGV4cGlyZXMuc2V0VGltZShleHBpcmVzLmdldFRpbWUoKSArICgxICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xyXG5cdC8vIGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyAnPScgKyB2YWx1ZSArICc7ZXhwaXJlcz0nICsgZXhwaXJlcy50b1VUQ1N0cmluZygpO1xyXG5cdHZhciBkID0gbmV3IERhdGUoKTtcclxuXHRkLnNldFRpbWUoZC5nZXRUaW1lKCkgKyAoZXhkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xyXG5cdHZhciBleHBpcmVzID0gXCJleHBpcmVzPVwiICsgZC50b1VUQ1N0cmluZygpO1xyXG5cdGRvY3VtZW50LmNvb2tpZSA9IGNuYW1lICsgXCI9XCIgKyBjdmFsdWUgKyBcIjtcIiArIGV4cGlyZXMgKyBcIjtwYXRoPS9cIjtcclxufVxyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHNldENvb2tpZShuYW1lLCB2YWx1ZSkge1xyXG4vLyBcdC8vZG9jdW1lbnQuY29va2llID0gbmFtZSArIFwiPVwiICsgdmFsdWUgKyBcIjsgZXhwaXJlcz1UaHUsIDE4IERlYyAyMDEzIDEyOjAwOjAwIEdNVFwiO1xyXG4vLyBcdC8vLmNvb2tpZShuYW1lLCB2YWx1ZSwge2V4cGlyZXM6MzY1LHBhdGg6Jy9jb29raWVzJ30pO1xyXG4vLyBcdHZhciBleHBpcmVzID0gbmV3IERhdGUoKTtcclxuLy8gXHRleHBpcmVzLnNldFRpbWUoZXhwaXJlcy5nZXRUaW1lKCkgKyAoMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcclxuLy8gXHRkb2N1bWVudC5jb29raWUgPSBuYW1lICsgJz0nICsgdmFsdWUgKyAnO2V4cGlyZXM9JyArIGV4cGlyZXMudG9VVENTdHJpbmcoKTtcclxuLy8gfVxuZXhwb3J0IGZ1bmN0aW9uIGdldERheXNCZXR3ZWVuIChzdGFydERhdGVUaW1lLCBlbmREYXRlVGltZSkge1xyXG4gICAgbGV0IG1zUGVyRGF5ID0gOC42NGU3O1xyXG4gICAgLy8gQ29weSBkYXRlcyBzbyBkb24ndCBtZXNzIHRoZW0gdXBcclxuICAgIGxldCBzZCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZVRpbWUpO1xyXG4gICAgbGV0IGVkID0gbmV3IERhdGUoZW5kRGF0ZVRpbWUpO1xyXG4gICAgLy8gU2V0IHRvIG5vb24gLSBhdm9pZCBEU1QgZXJyb3JzXHJcbiAgICBzZC5zZXRIb3VycygxMiwgMCwgMCk7XHJcbiAgICBlZC5zZXRIb3VycygxMiwgMCwgMCk7XHJcbiAgICAvLyBSb3VuZCB0byByZW1vdmUgZGF5bGlnaHQgc2F2aW5nIGVycm9yc1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGVkIC0gc2QpIC8gbXNQZXJEYXkpO1xyXG59XHJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE15U1FMRGF0ZVRpbWVTdHJpbmcoKSB7XHJcbiAgICBsZXQgbm93ID0gbmV3IERhdGUoKTtcclxuICAgIGxldCB5ZWFyID0gbm93LmdldEZ1bGxZZWFyKCk7XHJcbiAgICBsZXQgbW9udGggPSBub3cuZ2V0TW9udGgoKSArIDE7XHJcbiAgICBsZXQgZGF5ID0gbm93LmdldERhdGUoKTtcclxuICAgIGxldCBob3VyID0gbm93LmdldEhvdXJzKCk7XHJcbiAgICBsZXQgbWludXRlID0gbm93LmdldE1pbnV0ZXMoKTtcclxuICAgIGxldCBzZWNvbmQgPSBub3cuZ2V0U2Vjb25kcygpO1xyXG4gICAgaWYgKG1vbnRoLnRvU3RyaW5nKCkubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgbW9udGggPSAnMCcgKyBtb250aDtcclxuICAgIH1cclxuICAgIGlmIChkYXkudG9TdHJpbmcoKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBkYXkgPSAnMCcgKyBkYXk7XHJcbiAgICB9XHJcbiAgICBpZiAoaG91ci50b1N0cmluZygpLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGhvdXIgPSAnMCcgKyBob3VyO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pbnV0ZS50b1N0cmluZygpLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIG1pbnV0ZSA9ICcwJyArIG1pbnV0ZTtcclxuICAgIH1cclxuICAgIGlmIChzZWNvbmQudG9TdHJpbmcoKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBzZWNvbmQgPSAnMCcgKyBzZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBsZXQgc3RyID0geWVhciArICcvJyArIG1vbnRoICsgJy8nICsgZGF5ICsgJyAnICsgaG91ciArICc6JyArIG1pbnV0ZSArICc6JyArIHNlY29uZDtcclxuICAgIHJldHVybiBzdHI7XHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VUtEYXRlKGR0ZSl7XHJcbiAgICBsZXQgb3V0cHV0ID0gZHRlLmdldERheSgpICsgXCItXCIgKyAoZHRlLmdldE1vbnRoKCkrMSkgKyBcIi1cIiArIGR0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFVrRGF0ZUZyb21EYkRhdGVUaW1lIChpbnB1dCkge1xyXG4gICAgLy8gXCIyMDE2LTA0LTA4IDIxOjExOjU5XCIgdG8gVUsgZGF0ZVxyXG4gICAgaWYgKGlucHV0ID09PSBcIlwiIHx8IGlucHV0ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibm8gaW5wdXRcIjtcclxuICAgIH1cclxuICAgIGxldCBEYXRlVGltZSA9IGlucHV0LnNwbGl0KFwiIFwiKTtcclxuICAgIGxldCBEYXRlUGFydHMgPSBEYXRlVGltZVswXS5zcGxpdChcIi1cIik7XHJcbiAgICBsZXQgVUtEYXRlID0gRGF0ZVBhcnRzWzJdICsgXCIvXCIgKyBEYXRlUGFydHNbMV0gKyBcIi9cIiArIERhdGVQYXJ0c1swXTtcclxuICAgIHJldHVybiBVS0RhdGU7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRVa0RhdGVUaW1lRnJvbURiRGF0ZVRpbWUgIChpbnB1dCkge1xyXG4gICAgLy8gXCIyMDE2LTA0LTA4IDIxOjExOjU5XCIgdG8gVUsgZGF0ZSB0aW1lXHJcbiAgICBsZXQgRGF0ZVRpbWUgPSBpbnB1dC5zcGxpdChcIiBcIik7XHJcbiAgICBsZXQgRGF0ZVBhcnRzID0gRGF0ZVRpbWVbMF0uc3BsaXQoXCItXCIpO1xyXG4gICAgbGV0IFRpbWVQYXJ0cyA9IERhdGVUaW1lWzFdLnNwbGl0KFwiOlwiKTtcclxuICAgIGxldCBVS0RhdGUgPSBEYXRlUGFydHNbMl0gKyBcIi9cIiArIERhdGVQYXJ0c1sxXSArIFwiL1wiICsgRGF0ZVBhcnRzWzBdO1xyXG4gICAgbGV0IFRpbWUgPSBUaW1lUGFydHNbMF0gKyBcIjpcIiArIFRpbWVQYXJ0c1sxXTtcclxuICAgIHJldHVybiAoVUtEYXRlICsgXCIgXCIgKyBUaW1lKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFVTRGF0ZShkdGUpe1xyXG4gICAgbGV0IG91dHB1dCA9IGR0ZS5nZXRGdWxsWWVhcigpICsgXCItXCIgKyAoZHRlLmdldE1vbnRoKCkrMSkgKyBcIi1cIiArIChkdGUuZ2V0RGF5KCkrMSlcclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRUbyhlbGVtZW50T3JJZCxtc2csZW5kT2ZMaW5lPVwiPGJyPlwiKXtcclxuICAgIC8vIFdBUk5JTkc6IElFMTEgV29udCBwbGF5IG5pY2UgZXZlbiB3aXRoIHdlYnBhY2sgYmFiZWwgb24gZGVmYXVsdHMgb2YgYXJnc1xyXG4gICAgLy8gV0FSTklORzogVGhpcyB3aWxsIG5vdCBiZSBidWlsdCBmb3IgSUUgY29tcGF0aWJpbGl0eSAtIHBsZWFzZSB1c2UgYWZ0Yy5qcyBmb3IgdGhhdCBucG0gaSBhZnRjLmpzXHJcbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQobykge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IC8vRE9NMlxyXG4gICAgICAgICAgICAgICAgbyAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvICE9PSBudWxsICYmIG8ubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT09IFwic3RyaW5nXCJcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBlbGUgPSBmYWxzZTtcclxuICAgIGlmICh0eXBlb2YoZWxlbWVudE9ySWQpID09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgIGVsZW1lbnRPcklkID0gZWxlbWVudE9ySWQucmVwbGFjZShcIiNcIixcIlwiKTtcclxuICAgICAgICBlbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50T3JJZCk7XHJcbiAgICAgICAgaWYgKCFlbGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQXBwZW5kVG8oKTogVW5hYmxlIHRvIGZpbmQgSUQgJ1wiICsgZWxlbWVudE9ySWQgKyBcIicgb24gdGhlIERPTSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZSA9IGVsZW1lbnRPcklkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0VsZW1lbnQoZWxlKSl7XHJcbiAgICAgICAgZWxlLmlubmVySFRNTCA9IGVsZS5pbm5lckhUTUwgKyBtc2cgKyBlbmRPZkxpbmU7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiQXBwZW5kVG8oKTogVW5hYmxlIHRvIGxvZyB0byBlbGVtZW50IG9yIGlkIHByb3ZpZGVkIVwiKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVsZW1lbnRPcklkKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcblxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaERlYnVnKG5vLGVsZSkge1xyXG4gICAgLy8gcmV0dXJuIGlkJ3Mgbm90IHRoZSBkaXYgY3JlYXRlIGVsZW1lbnRzIGFzIHRoZXNlIGFyZSB0eXBlIG9mIG9iamVjdCBhbmQgbm90IGh0bWwgZWxlbWVudFxyXG4gICAgbGV0IGlkcyA9IFtdO1xyXG5cclxuICAgIGxldCBkZWJ1Z0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICBkZWJ1Z0NvbnRhaW5lci5pZCA9IFwiZGVidWctY29udGFpbmVyXCI7XHJcbiAgICBkZWJ1Z0NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBcIjk5OTk5OVwiO1xyXG4gICAgZGVidWdDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICBkZWJ1Z0NvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiNXB4XCI7XHJcbiAgICBkZWJ1Z0NvbnRhaW5lci5zdHlsZS50b3AgPSBcIjVweFwiO1xyXG4gICAgZGVidWdDb250YWluZXIuc3R5bGUudGV4dEFsZ2luID0gXCJyaWdodFwiO1xyXG5cclxuXHJcbiAgICB3aW5kb3cuYWZ0Y0RlYnVnID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBubzsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHIgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqOTk5OTk5OTk5OSk7XHJcbiAgICAgICAgbGV0IGlkID0gXCJhZnRjLWRlYnVnLWNvbnRhaW5lci1cIiArIHI7XHJcbiAgICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgZGl2LmlkID0gaWQ7XHJcbiAgICAgICAgZGl2LnN0eWxlLm1pbldpZHRoID0gXCI1MHB4XCI7XHJcbiAgICAgICAgLy8gZGl2LnN0eWxlLmhlaWdodCA9IFwiMjBweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIjNweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS5ib3JkZXIgPSBcIjFweCBkYXNoZWQgIzk5OTk5OVwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gXCIxcHggMnB4IDJweCA0cHhcIjtcclxuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZCA9IFwiUkdCQSgyNTUsMjU1LDI1NSwwLjkyKVwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS5jb2xvciA9IFwiIzAwMDAwMFwiO1xyXG4gICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZGVidWctcm93XCIpO1xyXG4gICAgICAgIGRlYnVnQ29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmlubmVySFRNTCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZnRjRGVidWcucHVzaChkaXYpO1xyXG4gICAgICAgIGlkcy5wdXNoKGlkKTtcclxuICAgIH1cclxuICAgIGlmIChlbGUpe1xyXG4gICAgICAgIGVsZS5hcHBlbmRDaGlsZChkZWJ1Z0NvbnRhaW5lcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGVidWdDb250YWluZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUud2FybihcIkF0dGFjaERlYnVnKCk6IEF0dGFjaGVkIVwiKTtcclxuICAgIGNvbnNvbGUud2FybihcIkF0dGFjaERlYnVnKCk6IFVzZSBEZWJ1Z1RvKGluZGV4LHN0cmluZykgdG8gd3JpdGUgZGlyZWN0bHkgdG8gZGVidWcgZWxlbWVudHMuXCIpO1xyXG4gICAgcmV0dXJuIGlkcztcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnVG8oaW5kZXgsIHN0cikge1xyXG4gICAgaWYgKHdpbmRvdy5hZnRjRGVidWcpIHtcclxuICAgICAgICBpZiAod2luZG93LmFmdGNEZWJ1Z1tpbmRleF0pIHtcclxuICAgICAgICAgICAgd2luZG93LmFmdGNEZWJ1Z1tpbmRleF0uaW5uZXJIVE1MID0gc3RyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuZXhwb3J0IGZ1bmN0aW9uIGxvZyhhcmcpIHtcclxuICAgIGNvbnNvbGUubG9nKGFyZyk7XHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gbG9nVG8oZWxlbWVudE9ySWQsbXNnLGFwcGVuZD1mYWxzZSxlbmRPZkxpbmU9XCJcIil7XHJcbiAgICAvLyBXQVJOSU5HOiBJRTExIFdvbnQgcGxheSBuaWNlIGV2ZW4gd2l0aCB3ZWJwYWNrIGJhYmVsIG9uIGRlZmF1bHRzIG9mIGFyZ3NcclxuICAgIC8vIFdBUk5JTkc6IFRoaXMgd2lsbCBub3QgYmUgYnVpbHQgZm9yIElFIGNvbXBhdGliaWxpdHkgLSBwbGVhc2UgdXNlIGFmdGMuanMgZm9yIHRoYXQgbnBtIGkgYWZ0Yy5qc1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXHJcbiAgICAgICAgICAgICAgICBvICYmIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGVsZSA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZihlbGVtZW50T3JJZCkgPT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgZWxlbWVudE9ySWQgPSBlbGVtZW50T3JJZC5yZXBsYWNlKFwiI1wiLFwiXCIpO1xyXG4gICAgICAgIGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRPcklkKTtcclxuICAgICAgICBpZiAoIWVsZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJMb2dUbygpOiBVbmFibGUgdG8gZmluZCBJRCAnXCIgKyBlbGVtZW50T3JJZCArIFwiJyBvbiB0aGUgRE9NIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlID0gZWxlbWVudE9ySWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRWxlbWVudChlbGUpKXtcclxuICAgICAgICBpZiAoYXBwZW5kID09PSB0cnVlKXtcclxuICAgICAgICAgICAgZWxlLmlubmVySFRNTCA9IGVsZS5pbm5lckhUTUwgKyBtc2cgKyBlbmRPZkxpbmU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZWxlLmlubmVySFRNTCA9IG1zZyArIGVuZE9mTGluZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiTG9nVG8oKTogVW5hYmxlIHRvIGxvZyB0byBlbGVtZW50IG9yIGlkIHByb3ZpZGVkIVwiKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVsZW1lbnRPcklkKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldElFVmVyc2lvbiAoKSB7XHJcbiAgICBsZXQgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oPzpNU0lFIHxUcmlkZW50XFwvLio7IHJ2OikoXFxkKykvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IHBhcnNlSW50KG1hdGNoWzFdKSA6IHVuZGVmaW5lZDtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE9TKHRlc3RBZ2VudCkge1xyXG4gICAgbGV0IHVzZXJBZ2VudDtcclxuXHJcbiAgICBpZiAoIXRlc3RBZ2VudCl7XHJcbiAgICAgICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdXNlckFnZW50ID0gdGVzdEFnZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHVzZXJBZ2VudCA9IHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIFdpbmRvd3MgUGhvbmUgbXVzdCBjb21lIGZpcnN0IGJlY2F1c2UgaXRzIFVBIGFsc28gY29udGFpbnMgXCJBbmRyb2lkXCIhXHJcbiAgICBpZiAoL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcIndpbmRvd3MgcGhvbmVcIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTYW1zdW5nIEJyb3dzZXIgZGV0ZWN0aW9uIFM4XHJcbiAgICBpZiAoL3NhbXN1bmdicm93c2VyL2kudGVzdCh1c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3M6XCJhbmRyb2lkXCIsXHJcbiAgICAgICAgICAgIHVzZXJBZ2VudDp1c2VyQWdlbnRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBpZiAoL2FuZHJvaWQvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcImFuZHJvaWRcIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcImlvc1wiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLy8gV2luZG93cyBQaG9uZSBtdXN0IGNvbWUgZmlyc3QgYmVjYXVzZSBpdHMgVUEgYWxzbyBjb250YWlucyBcIkFuZHJvaWRcIlxyXG4gICAgaWYgKC93aW42NHx3aW4zMnx3aW4xNnx3aW45NXx3aW45OHx3aW5kb3dzIDIwMDB8d2luZG93cyB4cHxtc2llfHdpbmRvd3MgbnQgNi4zOyB0cmlkZW50fHdpbmRvd3MgbnR8d2luZG93cy9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9zOlwid2luZG93c1wiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAoL29zIHgvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcIm9zeFwiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgvbWFjaW50b3NofG9zeC9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9zOlwib3N4XCIsXHJcbiAgICAgICAgICAgIHVzZXJBZ2VudDp1c2VyQWdlbnRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC9vcGVuYnNkL2kudGVzdCh1c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3M6XCJvcGVuIGJzZFwiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAoL3N1bm9zL2kudGVzdCh1c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3M6XCJzdW5vc1wiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgaWYgKC9jcmtleS9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9zOlwiY2hyb21lY2FzdFwiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgvYXBwbGV0di9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9zOlwiYXBwbGUgdHZcIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoL3dpaXUvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcIm5pbnRlbmRvIHdpaXVcIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoL25pbnRlbmRvIDNkcy9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9zOlwibmludGVuZG8gM2RzXCIsXHJcbiAgICAgICAgICAgIHVzZXJBZ2VudDp1c2VyQWdlbnRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC9wbGF5c3RhdGlvbi9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9zOlwicGxheXN0YXRpb25cIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoL2tpbmRsZS9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9zOlwiYW1hem9uIGtpbmRsZVwiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgvIGNyb3MgL2kudGVzdCh1c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3M6XCJjaHJvbWUgb3NcIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGlmICgvdWJ1bnR1L2kudGVzdCh1c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3M6XCJ1YnVudHVcIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKC9nb29nbGVib3QvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcImdvb2dsZSBib3RcIixcclxuICAgICAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoL2Jpbmdib3QvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcImJpbmcgYm90XCIsXHJcbiAgICAgICAgICAgIHVzZXJBZ2VudDp1c2VyQWdlbnRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKC95YWhvbyEgc2x1cnAvaS50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvczpcInlhaG9vIGJvdFwiLFxyXG4gICAgICAgICAgICB1c2VyQWdlbnQ6dXNlckFnZW50XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvczogZmFsc2UsXHJcbiAgICAgICAgdXNlckFnZW50OnVzZXJBZ2VudFxyXG4gICAgfTtcclxufVxyXG4vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXHJcblxyXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FuZHJvaWQoKXtcclxuICAgIGxldCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmICgvd2luZG93cyBwaG9uZS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgaXNBbmRyb2lkID0gdWEuaW5kZXhPZihcImFuZHJvaWRcIikgPiAtMTsgLy8mJiB1YS5pbmRleE9mKFwibW9iaWxlXCIpO1xyXG4gICAgICAgIHJldHVybiBpc0FuZHJvaWQ7XHJcbiAgICB9XHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gaXNDaHJvbWUoKSB7XHJcbiAgICB2YXIgaXNDaHJvbWl1bSA9IHdpbmRvdy5jaHJvbWU7XHJcbiAgICB2YXIgd2luTmF2ID0gd2luZG93Lm5hdmlnYXRvcjtcclxuICAgIHZhciB2ZW5kb3JOYW1lID0gd2luTmF2LnZlbmRvcjtcclxuICAgIHZhciBpc09wZXJhID0gdHlwZW9mIHdpbmRvdy5vcHIgIT09IFwidW5kZWZpbmVkXCI7XHJcbiAgICB2YXIgaXNJRWVkZ2UgPSB3aW5OYXYudXNlckFnZW50LmluZGV4T2YoXCJFZGdlXCIpID4gLTE7XHJcbiAgICB2YXIgaXNJT1NDaHJvbWUgPSB3aW5OYXYudXNlckFnZW50Lm1hdGNoKFwiQ3JpT1NcIik7XHJcblxyXG4gICAgaWYgKGlzSU9TQ2hyb21lKSB7XHJcbiAgICAgICAgLy8gaXMgR29vZ2xlIENocm9tZSBvbiBJT1NcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgaXNDaHJvbWl1bSAhPT0gbnVsbCAmJlxyXG4gICAgICAgIHR5cGVvZiBpc0Nocm9taXVtICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgdmVuZG9yTmFtZSA9PT0gXCJHb29nbGUgSW5jLlwiICYmXHJcbiAgICAgICAgaXNPcGVyYSA9PT0gZmFsc2UgJiZcclxuICAgICAgICBpc0lFZWRnZSA9PT0gZmFsc2VcclxuICAgICkge1xyXG4gICAgICAgIC8vIGlzIEdvb2dsZSBDaHJvbWVcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gbm90IEdvb2dsZSBDaHJvbWVcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0VkZ2UgKCkge1xyXG4gICAgLy9sZXQgaXNFZGdlID0gIWlzSUUgJiYgISF3aW5kb3cuU3R5bGVNZWRpYTsgLy8gRWRnZSAyMCtcclxuICAgIGxldCBlZGdlID0gZmFsc2U7XHJcbiAgICBpZiAoL0VkZ2VcXC9cXGQuL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICAgIGVkZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVkZ2U7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVGb3ggKCkge1xyXG4gICAgLy8gbGV0IGlzX2ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTE7XHJcbiAgICAvLyByZXR1cm4gaXNfZmlyZWZveDtcclxuICAgIHJldHVybiAodHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0lFICgpIHtcclxuICAgIC8vIGxldCBpc19pZSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdNU0lFJykgPiAtMTtcclxuICAgIC8vIHJldHVybiBpc19pZTtcclxuICAgIC8vIHBhcmFtcy5pc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvTVNJRXxUcmlkZW50Lyk7XHJcbiAgICAvLyBwYXJhbXMuaXNJRSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTsgLy8gSVM5IGFuZCBhYm92ZVxyXG4gICAgcmV0dXJuIC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyBJbnRlcm5ldCBFeHBsb3JlciA2LTExXHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gaXNJT1MoKSB7XHJcbiAgICBsZXQgaURldmljZXMgPSBbXHJcbiAgICAgICAgJ2lQYWQgU2ltdWxhdG9yJyxcclxuICAgICAgICAnaVBob25lIFNpbXVsYXRvcicsXHJcbiAgICAgICAgJ2lQb2QgU2ltdWxhdG9yJyxcclxuICAgICAgICAnaVBhZCcsXHJcbiAgICAgICAgJ2lQaG9uZScsXHJcbiAgICAgICAgJ2lQb2QnXHJcbiAgICBdO1xyXG5cclxuICAgIGlmICghIW5hdmlnYXRvci5wbGF0Zm9ybSkge1xyXG4gICAgICAgIHdoaWxlIChpRGV2aWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gaURldmljZXMucG9wKCkpeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gaXNNb2JpbGUoKXtcclxuICAgIC8vIFdpbmRvd3MgUGhvbmUgbXVzdCBjb21lIGZpcnN0IGJlY2F1c2UgaXRzIFVBIGFsc28gY29udGFpbnMgXCJBbmRyb2lkXCIhXHJcbiAgICBsZXQgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBmdW5jdGlvbjogaXNNb2JpbGUoKVxyXG4gKiBAZGVzYzogRGV0ZWN0cyBpZiB0aGUgZGV2aWNlIHlvdSBhcmUgdXNpbmcgaXMgYSBtb2JpbGUgb3Igbm90XHJcbiAqIEByZXR1cm4gYm9vbGVhblxyXG4gKiBAbGluazogaHR0cHM6Ly9jb2RlcGVuLmlvL0FsbEZvclRoZUNvZGUvcGVuL0tSYkxkbVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhKCkge1xyXG4gICAgLy8gbGV0IGlzQ2hyb21pdW0gPSB3aW5kb3cuY2hyb21lO1xyXG4gICAgLy8gbGV0IGlzT3BlcmEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiT1BSXCIpID4gLTEgfHwgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk9wZXJhXCIpID4gLTE7XHJcbiAgICAvLyBsZXQgaXNPcGVyYSA9IChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9PcGVyYXxPUFJcXC8vKSA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICBsZXQgaXNPcGVyYSA9ICghIXdpbmRvdy5vcHIgJiYgISFvcHIuYWRkb25zKSB8fCAhIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMDtcclxuICAgIHJldHVybiBpc09wZXJhO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XHJcbiAgICAvLyBsZXQgaXNfc2FmYXJpID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3NhZmFyaScpID4gLTE7XHJcbiAgICAvLyByZXR1cm4gaXNfc2FmYXJpO1xyXG4gICAgcmV0dXJuIC9jb25zdHJ1Y3Rvci9pLnRlc3Qod2luZG93LkhUTUxFbGVtZW50KSB8fCAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl1cIjsgfSkoIXdpbmRvd1snc2FmYXJpJ10gfHwgKHR5cGVvZiBzYWZhcmkgIT09ICd1bmRlZmluZWQnICYmIHNhZmFyaS5wdXNoTm90aWZpY2F0aW9uKSk7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50T2Zmc2V0VG9wKGVsZW1lbnRJZCkge1xyXG4gICAgbGV0IGVsZW1lbnQgPSBnZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xyXG4gICAgbGV0IGN1cnRvcCA9IDA7XHJcbiAgICBpZiAoZWxlbWVudC5oYXNPd25Qcm9wZXJ0eShcIm9mZnNldFBhcmVudFwiKSl7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjdXJ0b3AgKz0gZWxlbWVudC5vZmZzZXRUb3A7XHJcbiAgICAgICAgfSB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50KTtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChbY3VydG9wXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnRPcklkLCBjKSB7XHJcbiAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRPcklkKSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50T3JJZC5jbGFzc0xpc3QuY29udGFpbnMoYyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBnZXRFbGVtZW50QnlJZChlbGVtZW50T3JJZCkuY2xhc3NMaXN0LmNvbnRhaW5zKGMpO1xyXG4gICAgfVxyXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0SFRNTChlbGVtZW50T3JJZCwgc3RyLCBtb2RlID0gXCJzZXRcIikge1xyXG4gICAgbGV0IGVsZTtcclxuICAgIGlmICh0eXBlb2YgKGVsZW1lbnRPcklkKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRPcklkKTtcclxuICAgICAgICBpZiAoIWVsZSkge1xyXG4gICAgICAgICAgICBlbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnRPcklkKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZSA9IGVsZW1lbnRPcklkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbGUpIHtcclxuXHJcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhcHBlbmRcIjpcclxuICAgICAgICAgICAgICAgIGVsZS5pbm5lckhUTUwgKz0gc3RyICsgXCI8YnI+XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInByZXBlbmRcIjpcclxuICAgICAgICAgICAgICAgIGVsZS5pbm5lckhUTUwgPSBzdHIgKyBcIjxicj5cIiArIGVsZS5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGVsZS5pbm5lckhUTUwgPSBzdHI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgIFxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwic2V0SFRNTChlbGVtZW50T3JJZCwgc3RyKTogVXNhZ2UgZXJyb3I6IFVuYWJsZSB0byByZXRyaWV2ZSBlbGVtZW50IGlkIG9yIHVzZSBlbGVtZW50IFtcIiArIGVsZW1lbnRPcklkICsgXCJdXCI7XHJcbiAgICB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24oZWwpIHtcclxuICAgIGxldCBwb3NpdGlvbiA9IHtcclxuICAgICAgICB0b3A6IGVsLm9mZnNldFRvcCxcclxuICAgICAgICBsZWZ0OiBlbC5vZmZzZXRMZWZ0XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChlbC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICBsZXQgcGFyZW50UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHRvcDogZWwub2Zmc2V0UGFyZW50Lm9mZnNldFRvcCxcclxuICAgICAgICAgICAgbGVmdDogZWwub2Zmc2V0UGFyZW50Lm9mZnNldExlZnRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBwb3NpdGlvbi50b3AgKz0gcGFyZW50UG9zaXRpb24udG9wO1xyXG4gICAgICAgIHBvc2l0aW9uLmxlZnQgKz0gcGFyZW50UG9zaXRpb24ubGVmdDtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRQb3MoZWwpIHtcclxuICAgIGxldCB4ID0gMDtcclxuICAgIGxldCB5ID0gMDtcclxuICAgIHdoaWxlIChlbCAmJiAhaXNOYU4oZWwub2Zmc2V0TGVmdCkgJiYgIWlzTmFOKGVsLm9mZnNldFRvcCkpIHtcclxuICAgICAgICB4ICs9IGVsLm9mZnNldExlZnQgLSBlbC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIHkgKz0gZWwub2Zmc2V0VG9wIC0gZWwuc2Nyb2xsVG9wO1xyXG4gICAgICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbGVmdDogeCwgdG9wOiB5IH07XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RPTShvYmopIHtcclxuICAgIC8vIHRoaXMgd29ya3MgZm9yIG5ld2VyIGJyb3dzZXJzXHJcbiAgICB0cnkgeyByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7IH1cclxuXHJcbiAgICAgICAgLy8gdGhpcyB3b3JrcyBmb3Igb2xkZXIgYnJvd3NlcnNcclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSAmJlxyXG4gICAgICAgICAgICAob2JqLm5vZGVUeXBlID09PSAxKSAmJiAodHlwZW9mIG9iai5zdHlsZSA9PT0gXCJvYmplY3RcIikgJiZcclxuICAgICAgICAgICAgKHR5cGVvZiBvYmoub3duZXJEb2N1bWVudCA9PT0gXCJvYmplY3RcIik7XHJcbiAgICB9XHJcbn07XG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcclxuICAgIGxldCBhbnN3ZXIgPSAoXHJcbiAgICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXHJcbiAgICAgICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChhbnN3ZXIgIT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQyKGVsZW1lbnQpIHtcclxuICAgIC8vIHdvcmtzIG9uIG1ham9yIGJyb3dzZXJzIGJhY2sgdG8gSUU3XHJcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQ7XHJcbn1cclxuXG5leHBvcnQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcclxuICAgIC8vIFdBUk5JTkc6IGV4cG9ydCBjbGFzcyB3aWxsIG5vdCB3b3JrIGZvciB0cmFuc3BpbGUgdG8gSUUxMSAoREVMRVRFIENMQVNTIElGIFlPVSBTVElMTCBORUVEIGFmdGMtbW9kdWxlcyBvciB1c2UgU1JDIGZpbGUgaW5jbHVkZXMpXHJcbiAgICAvLyBOT1RFOiBBbHRlcm5hdGl2ZWx5IHVzZSBhZnRjLmpzIGZvciBFUzUgLSBucG0gaSBhZnRjLmpzXHJcbn1cclxuXHJcbi8qKiBqc28ge1xyXG4gKiBcIkZ1bmN0aW9uXCI6IFwiRXZlbnRNYW5hZ2VyLmpzXCIsXHJcbiAqIFwiRGVzY3JpcHRpb25cIjogXCJBIGNlbnRyYWxpc2VkIGV2ZW50IHN0YWNrIHdoZXJlIHlvdSBjYW4gaG9vayB5b3VyIGZ1bmN0aW9ucyAvIGNsYXNzJ3MgaW50byBmb3IgY2VudHJhbGlzZWQgcXVpY2sgYW5kIGVhc3kgZXZlbnQgYXBwbGljYXRpb24gZXZlbnQgaGFuZGxpbmcuXCIsXHJcbiAqIFwiTWV0aG9kc1wiOiBbXHJcbiAqICAgICAge1xyXG4gKiAgICAgICAgICBcIm5hbWVcIjogXCJsaXN0XCIsXHJcbiAqICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJMaXN0cyB3aGljaCBldmVudHMgaGF2ZSBiZWVuIGNyZWF0ZWQgYW5kIGF2YWlsYWJsZSBmb3IgZGlzcGF0Y2ggaW4gdGhlIEV2ZW50TWFuYWdlci5cIixcclxuICAqICAgICAgICAgIFwicmV0dXJuc1wiOiBcImNvbnNvbGUubG9nXCIsXHJcbiAqICAgICAgfSxcclxuICogICAgICB7XHJcbiAqICAgICAgICAgIFwibmFtZVwiOiBcImFkZFwiLFxyXG4gKiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQWRkcyBvciBjcmVhdGVzIGEgbmV3IGV2ZW50IHdpdGhpbiB0aGUgZXZlbnQgbWFuYWdlciBhbmQgYXR0YWNoZWQgYSBjYWxsYmFjayBmdW5jdGlvbiAvIGxpc3RlbmVyIG9iamVjdCB0byBiZSBjYWxsZWQgb24gZGlzcGF0Y2ggb2YgdGhpcyBldmVudC5cIixcclxuICogICAgICAgICAgXCJwYXJhbWV0ZXJzXCI6IFtcclxuICogICAgICAgICAgICAgIHtcclxuICogICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJldmVudE5hbWVcIixcclxuICogICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFwidHJ1ZVwiLFxyXG4gKiAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYWRkLlwiLFxyXG4gKiAgICAgICAgICAgICAgfSxcclxuICogICAgICAgICAgICAgIHtcclxuICogICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYWxsYmFja0Z1bmN0aW9uXCIsXHJcbiAgKiAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogXCJ0cnVlXCIsXHJcbiAqICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBsaXN0ZW5lciBvYmplY3QgLyBmdW5jdGlvbiB3aGljaCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXCIsXHJcbiAqICAgICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICBdLFxyXG4gKiAgICAgIH0sXHJcbiAqICAgICAge1xyXG4gKiAgICAgICAgICBcIm5hbWVcIjogXCJkaXNwYXRjaFwiLFxyXG4gKiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGlzcGF0Y2hlcyAvIFRyaWdnZXJzIGFuIGV2ZW50IGJ5IG5hbWUgZnJvbSB0aGUgRXZlbnRNYW5hZ2VyLlwiLFxyXG4gKiAgICAgICAgICBcInBhcmFtZXRlcnNcIjogW1xyXG4gKiAgICAgICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImV2ZW50TmFtZVwiLFxyXG4gKiAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogXCJ0cnVlXCIsXHJcbiAqICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBkaXNwYXRjaC5cIixcclxuICogICAgICAgICAgICAgIH1cclxuICogICAgICAgICAgXSxcclxuICogICAgICB9LFxyXG4gKiAgXVxyXG4gKiB9XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uUmVhZHkoZm4pIHtcclxuICAgIC8vIElFOStcclxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmbiwgMTApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZm4sIDEwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3Jkc0Zyb21TdHJpbmcoc3RyLCBtYXhXb3Jkcykge1xyXG4gICAgbGV0IHdvcmRDb3VudCA9IHN0ci5zcGxpdCgvXFxTKy8pLmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKlxcXFxTKyg/OlxcXFxzK1xcXFxTKyl7MCxcIiArIChtYXhXb3JkcyAtIDEpICsgXCJ9XCIpO1xyXG4gICAgbGV0IG91dHB1dCA9IFwiXCI7XHJcbiAgICBpZiAod29yZENvdW50ID49IG1heFdvcmRzKSB7XHJcbiAgICAgICAgb3V0cHV0ID0gc3RyLm1hdGNoKHJlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb3V0cHV0ID0gc3RyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgb3V0cHV0OiBvdXRwdXQsIHJlbWFpbmluZzogKG1heFdvcmRzIC0gd29yZENvdW50KSB9O1xyXG59XHJcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjLCBvbkNvbXBsZXRlLCBvblByb2dyZXNzKXtcclxuICAgIGxldCBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGRvY3VtZW50LmJvZHk7XHJcblxyXG4gICAgaWYgKCFoZWFkKXtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwibG9hZFNjcmlwdCgpOiBVbmFibGUgdG8gZ2V0IERPTSBIZWFkIG9yIERPTSBCb2R5IVwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcblxyXG4gICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuICAgIC8vIHJlcG9ydCBwcm9ncmVzcyBldmVudHNcclxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xyXG4gICAgICAgICAgICB2YXIgcGVyY2VudENvbXBsZXRlID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHBlcmNlbnRDb21wbGV0ZSk7XHJcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzKXtcclxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MocGVyY2VudENvbXBsZXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVuYWJsZSB0byBjb21wdXRlIHByb2dyZXNzIGluZm9ybWF0aW9uIHNpbmNlIHRoZSB0b3RhbCBzaXplIGlzIHVua25vd25cclxuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3Mpe1xyXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgLy8gbG9hZCByZXNwb25zZVRleHQgaW50byBhIG5ldyBzY3JpcHQgZWxlbWVudFxyXG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBzY3JpcHQuaW5uZXJIVE1MID0gZS50YXJnZXQucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG5cclxuICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gICAgIC8vIHRoaXMgcnVucyBhZnRlciB0aGUgbmV3IHNjcmlwdCBoYXMgYmVlbiBleGVjdXRlZC4uLlxyXG4gICAgICAgIC8vIH0pO1xyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIHhoci5vcGVuKFwiR0VUXCIsIHNyYyk7XHJcbiAgICB4aHIuc2VuZCgpO1xyXG59XG5leHBvcnQgY2xhc3MgWEhSIHtcclxuICAgIC8vIFdBUk5JTkc6IGV4cG9ydCBjbGFzcyB3aWxsIG5vdCB3b3JrIGZvciB0cmFuc3BpbGUgdG8gSUUxMSAoREVMRVRFIENMQVNTIElGIFlPVSBTVElMTCBORUVEIGFmdGMtbW9kdWxlcyBvciB1c2UgU1JDIGZpbGUgaW5jbHVkZXMpXHJcbiAgICAvLyBOT1RFOiBBbHRlcm5hdGl2ZWx5IHVzZSBhZnRjLmpzIGZvciBFUzUgLSBucG0gaSBhZnRjLmpzIChuZXcgWEhSKCkpXHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vaHR0cHM6Ly9qYXZhc2NyaXB0LmluZm8veG1saHR0cHJlcXVlc3RcclxuXHJcbiAgICAgICAgLy8gdmFyIGRlZnNcclxuICAgICAgICB0aGlzLmFyZ3MgPSB7XHJcbiAgICAgICAgICAgIHVybDogZmFsc2UsXHJcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogZmFsc2UsIC8vIGFrYSByZXF1ZXN0VHlwZSB0aGlzIGlzIGVpdGhlciBmb3JtIG9yIGpzb24geGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04Jyk7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogZmFsc2UsIC8vIGZvciBjbGllbnRzaWRlIHByb2Nlc3NpbmcgcmVzcG9uc2UgZGF0YSB0eXBlXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IDAsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBvbkVycm9yOiBmYWxzZSwgLy8gb25seSB0cmlnZ2VycyBpZiB0aGUgcmVxdWVzdCBjb3VsZG4ndCBiZSBtYWRlIGF0IGFsbFxyXG4gICAgICAgICAgICBvblByb2dyZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgb25DYW5jZWw6IGZhbHNlLFxyXG4gICAgICAgICAgICB1c2VybmFtZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiBmYWxzZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudXJsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51cmxQYXJhbXMgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMueGhyID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFByb2Nlc3MgYXJndW1lbnRzXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSAmJiB0eXBlb2YgKGFyZ3VtZW50c1swXSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1swXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJncy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdzW2tleV0gPSBhcmd1bWVudHNbMF1ba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmFyZ3MpO1xyXG5cclxuICAgICAgICAvLyBWYWxpZGF0ZVxyXG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFyZ3MudXJsID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gYFhIUigpOiBVc2FnZSBlcnJvcjogT3B0aW9uIFwidXJsXCIgaGFzIG5vdCBiZWVuIHNldCFcclxuUGxlYXNlIGVudGVyIGEgdmFsaWQgdXJsIHRvIG1ha2UgYSByZXF1ZXN0IHRvIWA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcclxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJncy5tZXRob2QgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBgWEhSKCk6IFVzYWdlIGVycm9yOiBPcHRpb24gXCJtZXRob2RcIiBoYXMgbm90IGJlZW4gc2V0IVxyXG5WYWxpZCBvcHRpb25zIGFyZTpcclxuICAgIFBPU1QsXHJcbiAgICBHRVRgO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XHJcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIGxvZyh0aGlzLmFyZ3MpO1xyXG4gICAgICAgIGxldCBzaG93RGF0YVR5cGVFcnJvciA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmFyZ3MuZGF0YSAhPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hcmdzLmRhdGFUeXBlID09PSBmYWxzZSl7XHJcbiAgICAgICAgICAgICAgICBzaG93RGF0YVR5cGVFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRoaXMuYXJncy5kYXRhVHlwZSkgPT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3MuZGF0YVR5cGUudG9Mb3dlckNhc2UoKSAhPT0gXCJqc29uXCIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdzLmRhdGFUeXBlLnRvTG93ZXJDYXNlKCkgIT09IFwiZm9ybVwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJncy5kYXRhVHlwZS50b0xvd2VyQ2FzZSgpICE9PSBcInRleHRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93RGF0YVR5cGVFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYgKHNob3dEYXRhVHlwZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBgWEhSKCk6IFVzYWdlIGVycm9yOiBJbnZhbGlkIFwiZGF0YVR5cGVcIiBoYXMgYmVlbiBzZXQhXHJcblZhbGlkIG9wdGlvbnMgYXJlOlxyXG4gICAgSlNPTiAgICAgICAgLSBzZW5kIGpzb24gc3RyaW5nXHJcbiAgICBGT1JNICAgICAgICAtIHNlbmQgZm9ybSBvYmplY3RcclxuICAgIFRFWFQgICAgICAgIC0gc2VuZCB1cmwgc3RyaW5nXHJcbmA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcclxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGxldCBzaG93UmVzcG9uc2VUeXBlRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5hcmdzLnJlc3BvbnNlVHlwZSA9PT0gZmFsc2Upe1xyXG4gICAgICAgICAgICBzaG93UmVzcG9uc2VUeXBlRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YodGhpcy5hcmdzLmRhdGFUeXBlKSA9PSBcInN0cmluZ1wiKXtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3MucmVzcG9uc2VUeXBlLnRvTG93ZXJDYXNlKCkgIT0gXCJ0ZXh0XCIgJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3MucmVzcG9uc2VUeXBlLnRvTG93ZXJDYXNlKCkgIT0gXCJkb2N1bWVudFwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdzLnJlc3BvbnNlVHlwZS50b0xvd2VyQ2FzZSgpICE9IFwianNvblwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdzLnJlc3BvbnNlVHlwZS50b0xvd2VyQ2FzZSgpICE9IFwiYXJyYXlidWZmZXJcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJncy5yZXNwb25zZVR5cGUudG9Mb3dlckNhc2UoKSAhPSBcImJsb2JcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dSZXNwb25zZVR5cGVFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHNob3dSZXNwb25zZVR5cGVFcnJvcikge1xyXG4gICAgICAgICAgICBsZXQgbXNnID1cclxuICAgICAgICAgICAgICAgIGBYSFIoKTogVXNhZ2Ugd2FybmluZzogT3B0aW9uIFwicmVzcG9uc2VUeXBlXCIgbm90IHNldCFcclxuVmFsaWQgb3B0aW9ucyBhcmU6XHJcbiAgICBqc29uIFxcdFxcdFxcdCBKU09OIChwYXJzZWQgYXV0b21hdGljYWxseSlcclxuICAgIGRvY3VtZW50IFxcdFxcdCBYTUwgRG9jdW1lbnQgKFhQYXRoIGV0YyksXHJcbiAgICB0ZXh0IFxcdFxcdFxcdCBzdHJpbmcsXHJcbiAgICBhcnJheWJ1ZmZlciBcXHQgQXJyYXlCdWZmZXIgZm9yIGJpbmFyeSBkYXRhLFxyXG4gICAgYmxvYiBcXHRcXHRcXHQgQmxvYiBmb3IgYmluYXJ5IGRhdGEsXHJcbmA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcclxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBpZiAodGhpcy5hcmdzLm9uQ29tcGxldGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBgWEhSKCk6IFVzYWdlIGVycm9yOiBPcHRpb24gXCJvbkNvbXBsZXRlXCIgaGFzIG5vdCBiZWVuIHNldCFcclxuWW91ciBtYWtpbmcgYSByZXF1ZXN0IGJ1dCBhcmUgbm90IGRvaW5nIGFueXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlPyBNYWtlIHN1cmUgdG8gc3VwcGx5IGFuIG9uQ29tcGxldGUgY2FsbGJhY2sgZnVuY3Rpb24uYDtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xyXG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIGlmICh2YWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxyXG5cclxuXHJcblxyXG4gICAgbWFrZVJlcXVlc3QoKSB7XHJcbiAgICAgICAgdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMuYXJncy50aW1lb3V0O1xyXG5cclxuXHJcbiAgICAgICAgLy8gR0VUXHJcbiAgICAgICAgLy8gQXBwZW5kIGRhdGEgdmFyaWFibGVzIHRvIHVybCBzdHJpbmcsIG9ubHkgaGFuZGxlIGpzb24sIGZvcm0gYW5kIHN0cmluZ1xyXG5cclxuICAgICAgICAvLyBQT1NUfHxQVVR8fERFTEVURXx8UEFUQ0hcclxuICAgICAgICAvLyBJZiBqc29uIHNlbmQganNvbiBvYmplY3RcclxuICAgICAgICAvLyBJZiBmb3JtIHNlbmQgZm9ybSBvYmplY3RcclxuICAgICAgICAvLyBJZiB0ZXh0IHNlbmQgc3RyaW5nXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFyZ3MubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT0gXCJnZXRcIikge1xyXG4gICAgICAgICAgICAvLyBHRVRcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJncy5kYXRhVHlwZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hcmdzLmRhdGFUeXBlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuYXJncy51cmwgKyBcIj9cIiArIHRoaXMuYXJncy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuYXJncy51cmwgKyBcIj9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IG9mIHRoaXMuYXJncy5kYXRhLmtleXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHYgPSB0aGlzLmFyZ3MuZGF0YS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybCArIGVuY29kZVVSSShrZXkpICsgXCI9XCIgKyBlbmNvZGVVUkkodikgKyBcIiZcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwianNvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuYXJncy51cmwgKyBcIj9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuYXJncy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5hcmdzLmRhdGFba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IHRoaXMuYXJncy5kYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2coa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwgKyBlbmNvZGVVUkkoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJKHYpICsgXCImXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRoaXMudXJsID0gXCIgKyB0aGlzLnVybCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuYXJncy51cmxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFBPU1QgfHwgUFVUIHx8IFBBVENIIHx8IERFTEVURVxyXG4gICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuYXJncy51cmxcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBvcGVuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJncy51c2VybmFtZSAhPT0gZmFsc2UgJiYgdGhpcy5hcmdzLnBhc3N3b3JkICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnhoci5vcGVuKHRoaXMuYXJncy5tZXRob2QsIHRoaXMudXJsLCB0aGlzLmFyZ3MudXNlcm5hbWUsIHRoaXMuYXJncy5wYXNzd29yZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy54aHIub3Blbih0aGlzLmFyZ3MubWV0aG9kLCB0aGlzLnVybCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNwb25zZVR5cGVcclxuICAgICAgICB0aGlzLnhoci5yZXNwb25zZVR5cGUgPSB0aGlzLmFyZ3MucmVzcG9uc2VUeXBlO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBTZXQgcmVxdWVzdEhlYWRlciB0eXBlIGFrYSBkYXRhVHlwZSBhbmQgc2VuZFxyXG4gICAgICAgIGlmICh0aGlzLmFyZ3MuZGF0YVR5cGUgIT09IGZhbHNlICYmIHR5cGVvZih0aGlzLmFyZ3MuZGF0YVR5cGUpID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmFyZ3MuZGF0YVR5cGUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkodGhpcy5hcmdzLmRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIga2V5IG9mIHRoaXMuYXJncy5kYXRhLmtleXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgdiA9IHRoaXMuYXJncy5kYXRhLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhrZXkgKyBcIiA9IFwiICsgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5hcmdzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5hcmdzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhoci5zZW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnhoci5zZW5kKCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gU2VuZFxyXG4gICAgICAgIC8vIGlmICh0aGlzLmFyZ3MuZGF0YSAhPT0gZmFsc2UgJiYgdGhpcy5hcmdzLmRhdGFUeXBlICE9PSBmYWxzZSl7XHJcbiAgICAgICAgLy8gICAgIGxvZyhcInNlbmRpbmcgZGF0YVwiKTtcclxuICAgICAgICAvLyAgICAgdGhpcy54aHIuc2VuZCh0aGlzLmFyZ3MuZGF0YSk7XHJcbiAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgdGhpcy54aHIuc2VuZCgpO1xyXG4gICAgICAgIC8vIH1cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBFdmVudCBMaXN0ZW5lcnNcclxuICAgICAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKGUpID0+IHRoaXMucHJvZ3Jlc3NIYW5kbGVyKGUpLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoZSkgPT4gdGhpcy5vbkxvYWRIYW5kbGVyKGUpLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IHRoaXMuZXJyb3JIYW5kbGVyKGUpLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKGUpID0+IHRoaXMuZXJyb3JIYW5kbGVyKGUpLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCAoZSkgPT4gdGhpcy5lcnJvckhhbmRsZXIoZSksIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxyXG5cclxuXHJcbiAgICBlcnJvckhhbmRsZXIoZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiWEhSLmVycm9ySGFuZGxlcigpXCIpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICBpZiAodGhpcy5hcmdzLm9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hcmdzLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxyXG5cclxuXHJcbiAgICBwcm9ncmVzc0hhbmRsZXIoZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiWEhSLnByb2dyZXNzSGFuZGxlcigpXCIpO1xyXG4gICAgICAgIC8vIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coYFJlY2VpdmVkICR7ZS5sb2FkZWR9IG9mICR7ZS50b3RhbH0gYnl0ZXNgKTtcclxuICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgJHtlLmxvYWRlZH0gYnl0ZXNgKTsgLy8gbm8gQ29udGVudC1MZW5ndGhcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coYFJlY2VpdmVkICR7ZXZlbnQubG9hZGVkfSBvZiAke2V2ZW50LnRvdGFsfWApO1xyXG4gICAgICAgIGlmICh0aGlzLmFyZ3Mub25Qcm9ncmVzcykge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3Mub25Qcm9ncmVzcyhlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXHJcblxyXG5cclxuICAgIG9uTG9hZEhhbmRsZXIoZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiWEhSLm9uTG9hZEhhbmRsZXIoKVwiKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgRG9uZSwgZ290ICR7dGhpcy54aHIucmVzcG9uc2UubGVuZ3RofSBieXRlc2ApO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMueGhyLnJlc3BvbnNlKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFyZ3Mub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3Mub25Db21wbGV0ZShlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXHJcblxyXG5cclxuICAgIGdldFJlc3BvbnNlSGVhZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy54aHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cclxuXHJcblxyXG4gICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnhocikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxyXG5cclxuXHJcbiAgICBnZXRSZXNwb25zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy54aHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGhyLnJlc3BvbnNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cclxuXHJcblxyXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIChlKSA9PiB0aGlzLnByb2dyZXNzSGFuZGxlcihlKSk7XHJcbiAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKGUpID0+IHRoaXMub25Mb2FkSGFuZGxlcihlKSk7XHJcbiAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiB0aGlzLmVycm9ySGFuZGxlcihlKSk7XHJcbiAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIChlKSA9PiB0aGlzLmVycm9ySGFuZGxlcihlKSk7XHJcbiAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRpbWVvdXRcIiwgKGUpID0+IHRoaXMuZXJyb3JIYW5kbGVyKGUpKTtcclxuICAgIH1cclxuICAgIC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cclxuXHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21Cb29sZWFuKCl7XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSA+PSAwLjU7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21GbG9hdChtaW4sIG1heCkge1xyXG4gICAgLy8gbGV0IHIgPSBmcm9tICsgKE1hdGgucmFuZG9tKCkqICh0byoyKSk7XHJcbiAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbik7XHJcbn07XHJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbUludChtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21UaGF0c05vdChtaW4sbWF4LG5vdCl7XHJcbiAgICBsZXQgciA9IG5vdDsgbGV0IGxpbSA9IDEwMDsgbGV0IHJ1bnMgPSAwO1xyXG4gICAgd2hpbGUgKHI9PT1ub3QgJiYgcnVucyA8IGxpbSl7XHJcbiAgICAgICAgcnVucysrO1xyXG4gICAgICAgIHIgPSBnZXRSYW5kb21JbnQobWluLG1heCk7XHJcbiAgICB9XHJcbiAgICBpZiAocnVucz49bGltKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAZnVuY3Rpb246IGdldFJhbmRvbVRoYXRzTm90KG1pbixtYXgsbm90KVxyXG4gKiBAZGVzYzogcmV0dXJucyBhIHJhbmRvbSBpbnQgYmV0d2VuIHlvdXIgc3BlY2lmaWVkIG1pbiBhbmQgbWF4IHZhbHVlcyBidXQgbmV2ZXIgdGhlIG5vdCB2YWx1ZVxyXG4gKiBAcGFyYW0gbWluIG51bWJlcjogdGhlIG1pbmltdW0geW91ciByYW5kb20gbnVtYmVyIGlzIGFsbG93ZWQgdG8gZ29cclxuICogQHBhcmFtIG1heCBudW1iZXI6IHRoZSBtYXhpbXVtIHlvdXIgcmFuZG9tIG51bWJlciBpcyBhbGxvd2VkIHRvIGdvXHJcbiAqIEBhbGlhczogZ2V0UmFuZG9tXHJcbiAqIEBsaW5rOiBodHRwczovL2NvZGVwZW4uaW8vQWxsRm9yVGhlQ29kZS9wZW4veUVCWk5xXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlKGEsYil7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoYSwgYikgLSBNYXRoLm1pbihhLCBiKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFdlaWdodGVkUmFuZG9tKG9kZHMsIGl0ZXJhdGlvbnMpIHtcclxuICAgIGlmICghb2Rkcykge1xyXG4gICAgICAgIG9kZHMgPSBbXHJcbiAgICAgICAgICAgIDAuNjgsIC8vIDBcclxuICAgICAgICAgICAgMC42OSwgLy8gMVxyXG4gICAgICAgICAgICAwLjY5OCwgLy8gMlxyXG4gICAgICAgICAgICAwLjY5MDksIC8vIDNcclxuICAgICAgICAgICAgMC42OCwgLy8gNFxyXG4gICAgICAgICAgICAwLjU4LCAvLyA1XHJcbiAgICAgICAgICAgIDAuNTcsIC8vIDZcclxuICAgICAgICAgICAgMC41NiwgLy8gN1xyXG4gICAgICAgICAgICAwLjQsIC8vIDhcclxuICAgICAgICAgICAgMC4zLCAvLyA5XHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGxldCB3ZWlnaHRzID0gW107XHJcbiAgICBsZXQgciA9IDA7XHJcbiAgICBsZXQgaU1heCA9IDA7XHJcbiAgICBsZXQgd01heCA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSBpbiBvZGRzKSB7XHJcbiAgICAgICAgaWYgKCF3ZWlnaHRzW2ldKSB7XHJcbiAgICAgICAgICAgIHdlaWdodHNbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBpdGVyYXRpb25zOyB4KyspIHtcclxuICAgICAgICAgICAgciA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgIC8vbG9nKHIudG9GaXhlZCgzKSArIFwiICAgXCIgKyBvZGRzW2ldLnRvRml4ZWQoMykpO1xyXG4gICAgICAgICAgICBpZiAociA8PSBvZGRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB3ZWlnaHRzW2ldICs9IG9kZHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh3ZWlnaHRzW2ldID4gd01heCkge1xyXG4gICAgICAgICAgICB3TWF4ID0gd2VpZ2h0c1tpXTtcclxuICAgICAgICAgICAgaU1heCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vbG9nKHdlaWdodHMpO1xyXG4gICAgLy9sb2coXCJ3TWF4ID0gXCIgKyB3TWF4ICsgXCIgICBpTWF4ID0gXCIgKyBpTWF4KTtcclxuICAgIHJldHVybiBpTWF4O1xyXG59O1xyXG4vKipcclxuICogQGZ1bmN0aW9uOiBnZXRXZWlnaHRlZFJhbmRvbShvZGRzLCBpdGVyYXRpb25zKVxyXG4gKiBAZGVzYzogR2V0IGEgd2VpZ2h0ZWQgcmFuZG9tIGJhc2VkIG9uIG9kZHMgYW5kIGl0ZXJhdGlvbnNcclxuICogQHBhcmFtIG9kZHMgYXJyYXk6IGFycmF5IG9mIG9kZHNcclxuICogQHBhcmFtIGl0ZXJhdGlvbnMgbnVtYmVyOiBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW4gb24gZWFjaCBudW1iZXIgdGVzdFxyXG4gKiBAbGluazogaHR0cHM6Ly9jb2RlcGVuLmlvL0FsbEZvclRoZUNvZGUvcGVuL1J5dldqWlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmVydGlhVG8oY3VycmVudCx0YXJnZXQsYW1vdW50KXtcclxuICAgIGlmIChhbW91bnQgPT0gMSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBsZXQgZGlzdFRvR28gPSB0YXJnZXQgLSBjdXJyZW50O1xyXG4gICAgbGV0IGRlbHRhID0gY3VycmVudCArIChkaXN0VG9HbyAqIGFtb3VudCk7XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGRpc3RUb0dvKSA8IDAuMDEpIHtcclxuICAgICAgICBkaXN0VG9HbyA9IDA7XHJcbiAgICAgICAgZGVsdGEgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVsdGE7XHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gaXNFdmVuKG4pIHtcclxuICAgIHJldHVybiBuICUgMiA9PT0gMDtcclxufVxyXG5cbmV4cG9ydCBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMobiAlIDIpID09PSAxO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXNlUmFuZ2UobWluLCBtYXgsIHYpIHtcclxuICAgIGxldCByYW5nZSA9IG1heCAtIG1pbjtcclxuICAgIGxldCBzdGVwID0gMSAvIHJhbmdlO1xyXG4gICAgbGV0IHIgPSAoc3RlcCAqICh2IC0gbWluKSk7XHJcbiAgICBpZiAodiA8IG1pbikge1xyXG4gICAgICAgIHIgPSAwO1xyXG4gICAgfSBlbHNlIGlmICh2ID4gbWF4KSB7XHJcbiAgICAgICAgciA9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFycmF5VG9GbG9hdChhcnIpIHtcclxuICAgIGxldCBjb252ZXJ0ZWQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnZlcnRlZCA9IHBhcnNlRmxvYXQoYXJyW2ldKTtcclxuICAgICAgICBpZiAoaXNOYU4oY29udmVydGVkKSl7XHJcbiAgICAgICAgICAgIGFycltpXSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXJyW2ldID0gY29udmVydGVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBcnJheVRvSW50KGFycikge1xyXG4gICAgbGV0IGNvbnZlcnRlZDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29udmVydGVkID0gcGFyc2VJbnQoYXJyW2ldKTtcclxuICAgICAgICBpZiAoaXNOYU4oY29udmVydGVkKSl7XHJcbiAgICAgICAgICAgIGFycltpXSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXJyW2ldID0gY29udmVydGVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvKHYsIGRlYykge1xyXG4gICAgcmV0dXJuICsoTWF0aC5yb3VuZChOdW1iZXIodiArIFwiZStcIiArIGRlYykpICsgXCJlLVwiICsgZGVjKTtcclxufVxyXG5cbmV4cG9ydCBjbGFzcyBGUFNNb25pdG9yIHtcclxuICAgIC8vIFdBUk5JTkc6IGV4cG9ydCBjbGFzcyB3aWxsIG5vdCB3b3JrIGZvciB0cmFuc3BpbGUgdG8gSUUxMSAoREVMRVRFIENMQVNTIElGIFlPVSBTVElMTCBORUVEIGFmdGMtbW9kdWxlcyBvciB1c2UgU1JDIGZpbGUgaW5jbHVkZXMpXHJcbiAgICAvLyBOT1RFOiBBbHRlcm5hdGl2ZWx5IHVzZSBhZnRjLmpzIGZvciBFUzUgLSBucG0gaSBhZnRjLmpzXHJcblxyXG4gICAgY29uc3RydWN0b3IoZWxlKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZG9tID0ge1xyXG4gICAgICAgICAgICBmcHM6IGZhbHNlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZwc1N0YWNrID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSA2MDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0ID0gMDtcclxuICAgICAgICB0aGlzLm5vdyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZUZwcyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xyXG4gICAgICAgIHRoaXMuYXZlcmFnZUZwcyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcblxyXG4gICAgICAgIGlmIChlbGUpe1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5mcHMgPSBlbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZwc1N0YWNrID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnN0YWNrU2l6ZSk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgdXBkYXRlKCl7XHJcbiAgICAgICAgdGhpcy5ub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWx0YSA9ICh0aGlzLm5vdyAtIHRoaXMubGFzdCkgLyAxMDAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lRnBzID0gMS90aGlzLmRlbHRhO1xyXG4gICAgICAgIC8vIGxvZyhcImN1cnJlbnRGcmFtZUZwcyA9IFwiICsgdGhpcy5jdXJyZW50RnJhbWVGcHMpO1xyXG5cclxuICAgICAgICB0aGlzLmZwc1N0YWNrW3RoaXMuaW5kZXhdID0gdGhpcy5jdXJyZW50RnJhbWVGcHM7XHJcblxyXG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xyXG4gICAgICAgIGZvcih0aGlzLmk9MDsgdGhpcy5pIDwgdGhpcy5zdGFja1NpemU7IHRoaXMuaSsrKXtcclxuICAgICAgICAgICAgdGhpcy50b3RhbCArPSB0aGlzLmZwc1N0YWNrW3RoaXMuaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmF2ZXJhZ2VGcHMgPSBNYXRoLnJvdW5kKCB0aGlzLnRvdGFsL3RoaXMuc3RhY2tTaXplICk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRvbS5mcHMpe1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5mcHMuaW5uZXJUZXh0ID0gdGhpcy5hdmVyYWdlRnBzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5ub3c7XHJcblxyXG4gICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnN0YWNrU2l6ZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEZwcygpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF2ZXJhZ2VGcHM7XHJcbiAgICB9XHJcbn1cclxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R1VJRCgpIHtcclxuICAgIGZ1bmN0aW9uIEFtaWdhKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKVxyXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXHJcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEFtaWdhKCkgKyBBbWlnYSgpICsgJy0nICsgQW1pZ2EoKSArICctJyArIEFtaWdhKCkgKyAnLScgK1xyXG4gICAgICAgIEFtaWdhKCkgKyAnLScgKyBBbWlnYSgpICsgQW1pZ2EoKSArIEFtaWdhKCk7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRVSUQobGVuKSB7XHJcbiAgICBpZiAobGVuID4gMzQpe1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJnZXRVSUQobGVuZ3RoKTogTGltaXQgZXJyb3I6IExlbmd0aCBtdXN0IGJlIDM0IG9yIGxvd2VyXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGxlbik7XHJcbiAgICB9XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FscGhhTnVtZXJpYyh2KSB7XHJcbiAgICByZXR1cm4gISgvXFxXLy50ZXN0KHYpKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcclxuICAgIHJldHVybiAhIWlucHV0ICYmIGlucHV0LmNvbnN0cnVjdG9yID09PSBBcnJheTtcclxuICAgIC8vcmV0dXJuIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2woaW5wdXQpIHtcclxuICAgIGlmICh0eXBlb2YgKGlucHV0KSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKGlucHV0KSB7XHJcbiAgICBpZiAodHlwZW9mIChpbnB1dCkgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcclxuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc051bWVyaWMobikge1xyXG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGN1dFN0cmluZ1RvKHMsIGxlbikge1xyXG4gICAgcmV0dXJuIHMuc3Vic3RyaW5nKDAsIGxlbik7XHJcbn1cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVIVE1MKHN0cikge1xyXG4gICAgaWYgKHR5cGVvZiAoc3RyKSAhPSBcInN0cmluZ1wiKSB7IGNvbnNvbGUuZXJyb3IoXCJlc2NhcGUoYXJnKTogdXNhZ2UgZXJyb3I6IGFyZyBuZWVkcyB0byBiZSBhIHN0cmluZyFcIik7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIGxldCByZXBsYWNlbWVudHMgPSB7XHJcbiAgICAgICAgXCI8XCI6IFwiJmx0O1wiLFxyXG4gICAgICAgIFwiPlwiOiBcIiZndDtcIixcclxuICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxyXG4gICAgICAgIFwiXFxcIlwiOiBcIiZxdW90O1wiLFxyXG4gICAgICAgIFwiYFwiOiBcIiYjMDM5O1wiXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bPD4mXCJdL2csIGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcclxuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRzW2NoYXJhY3Rlcl07XHJcbiAgICB9KTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuY2hvcih1cmwpIHtcclxuICAgIGlmICghdXJsKSB7IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmOyB9XHJcbiAgICBsZXQgYW5jaG9yQXZhaWxhYmxlID0gaXNJblN0cmluZyhcIiNcIiwgdXJsKTtcclxuICAgIGlmIChhbmNob3JBdmFpbGFibGUpIHtcclxuICAgICAgICByZXR1cm4gdXJsLnNsaWNlKHVybC5sYXN0SW5kZXhPZignIycpICsgMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGZ1bmN0aW9uOiBHZXRBbmNob3IodXJsKVxyXG4gKiBAZGVzYzogR2V0IGFuY2hvciBmcm9tIHVybFxyXG4gKiBAcGFyYW0gc3RyaW5nIHVybDogVGhlIHVybCB0byBnZXQgdGhlIGFuY2hvciBmcm9tXHJcbiAqIEBsaW5rOlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGVhbkpTT05TdHJpbmcgKHMpIHtcclxuICAgIC8vIHByZXNlcnZlIG5ld2xpbmVzLCBldGMgLSB1c2UgdmFsaWQgSlNPTlxyXG4gICAgcyA9IHMucmVwbGFjZSgvXFxcXG4vZywgXCJcXFxcblwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcJy9nLCBcIlxcXFwnXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXFxcXFwiJylcclxuICAgICAgICAucmVwbGFjZSgvXFxcXCYvZywgXCJcXFxcJlwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcci9nLCBcIlxcXFxyXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcXFx0L2csIFwiXFxcXHRcIilcclxuICAgICAgICAucmVwbGFjZSgvXFxcXGIvZywgXCJcXFxcYlwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcZi9nLCBcIlxcXFxmXCIpO1xyXG4gICAgLy8gcmVtb3ZlIG5vbi1wcmludGFibGUgYW5kIG90aGVyIG5vbi12YWxpZCBKU09OIGNoYXJzXHJcbiAgICBzID0gcy5yZXBsYWNlKC9bXFx1MDAwMC1cXHUwMDE5XSsvZywgXCJcIik7XHJcbiAgICByZXR1cm4gcztcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oaW5wdXQpIHtcclxuICAgIHJldHVybiBpbnB1dC5zbGljZSgoaW5wdXQubGFzdEluZGV4T2YoXCIuXCIpIC0gMSA+Pj4gMCkgKyAyKTtcclxuICAgIC8vIHJldHVybiAoaW5wdXQubWF0Y2goLyg/Oi4rLi4rW15cXC9dKyQpL2lnKSAhPSBudWxsKSA/IGlucHV0LnNwbGl0KCcuJykuc2xpY2UoLTEpIDogJ251bGwnO1xyXG5cclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExhc3RQYXJ0T2ZVcmwodXJsKSB7XHJcbiAgICBpZiAoIXVybCkge1xyXG4gICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcnQgPSB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XHJcbiAgICByZXR1cm4gcGFydDtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZyhsZW4pIHtcclxuICAgIGxldCB0ZXh0ID0gXCJcIjtcclxuICAgIGxldCBwb3NzaWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB0ZXh0ICs9IHBvc3NpYmxlLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZS5sZW5ndGgpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJpbmdCZXR3ZWVuKHN0ciwgc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIHN0ci5zcGxpdChzdGFydCkucG9wKCkuc3BsaXQoZW5kKS5zaGlmdCgpLnRyaW0oKTtcclxufVxyXG4vKipcclxuICogQGZ1bmN0aW9uOiBnZXRTdHJpbmdCZXR3ZWVuKGlucHV0LHN0YXJ0LGVuZClcclxuICogQGRlc2M6IEdldHMgYSBzdHJpbmcgYmV0d2VlbiB0d28gb3RoZXIgc3RyaW5nc1xyXG4gKiBAcGFyYW0gc3RyaW5nIGlucHV0OiBpbnB1dCBzdHJpbmcgdG8gY2hlY2tcclxuICogQHBhcmFtIHN0cmluZyBzdGFydDogc3RhcnQgc3RyaW5nIG1hcmtlclxyXG4gKiBAcGFyYW0gc3RyaW5nIGVuZDogZW5kIHN0cmluZyBtYXJrZXJcclxuICogQGxpbms6IGh0dHBzOi8vY29kZXBlbi5pby9BbGxGb3JUaGVDb2RlL3Blbi94eHh4eHh4XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmluZ3NCZXR3ZWVuMihzdHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGxldCBvcmlnID0gc3RyO1xyXG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcclxuICAgIC8vIGxvZyhvcmlnKTtcclxuICAgIC8vIGxvZyhcIi0tLS0tLS0tXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldEJldHdlZW4oKSB7XHJcbiAgICAgICAgLy8gbG9nKFwiQ0hFQ0tJTkc6IFwiICsgc3RyKTtcclxuICAgICAgICBsZXQgc3RhcnRNYXRjaEluZGV4ID0gc3RyLmluZGV4T2Yoc3RhcnQpOyAvLyBGaW5kIHN0YXJ0IG1hdGNoXHJcbiAgICAgICAgLy8gbG9nKFwic3RhcnRNYXRjaEluZGV4OiBcIiArIHN0YXJ0TWF0Y2hJbmRleCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0TWF0Y2hJbmRleCA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gICAgICAgIGxldCBzdGFydEN1dEluZGV4ID0gc3RhcnQubGVuZ3RoICsgc3RhcnRNYXRjaEluZGV4OyAvLyBjYWxjIHN0YXJ0IGN1dCBpbmRleFxyXG4gICAgICAgIC8vIGxvZyhcInN0YXJ0Q3V0SW5kZXg6IFwiICsgc3RhcnRDdXRJbmRleCk7XHJcblxyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoc3RhcnRDdXRJbmRleCwgc3RyLmxlbmd0aCk7IC8vIExUcmltIHRvIHN0YXJ0IGN1dCBpbmRleFxyXG4gICAgICAgIC8vIGxvZyhcIkNVVDogXCIgKyBzdHIpO1xyXG5cclxuICAgICAgICBsZXQgZW5kTWF0Y2hJbmRleCA9IHN0ci5pbmRleE9mKGVuZCk7IC8vIGZpbmQgZW5kIG1hdGNoIGluZGV4XHJcbiAgICAgICAgLy8gbG9nKFwiZW5kTWF0Y2hJbmRleDogXCIgKyBlbmRNYXRjaEluZGV4KTtcclxuICAgICAgICBpZiAoZW5kTWF0Y2hJbmRleCA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gICAgICAgIGxldCBiZXR3ZWVuID0gc3RyLnN1YnN0cmluZygwLCBlbmRNYXRjaEluZGV4KTsgLy8gZ2V0IHN0cmluZyBiZXR3ZWVuXHJcbiAgICAgICAgLy8gbG9nKFwiYmV0d2VlbjogXCIgKyBiZXR3ZWVuKTtcclxuICAgICAgICBsZXQgZW5kQ3V0SW5kZXggPSBlbmQubGVuZ3RoICsgZW5kTWF0Y2hJbmRleDtcclxuICAgICAgICAvL2xvZyhcImVuZEN1dEluZGV4OiBcIiArIGVuZEN1dEluZGV4KTtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKGVuZEN1dEluZGV4LCBzdHIubGVuZ3RoKTsgLy8gY3V0IG9mZiBlbmQgc3RyaW5nXHJcbiAgICAgICAgLy9sb2coXCJGSU5BTDogXCIgKyBzdHIpO1xyXG4gICAgICAgIHJldHVybiBiZXR3ZWVuO1xyXG4gICAgfVxyXG4gICAgbGV0IGxpbSA9IDUwMDsgLy8gV2FudCB0byBsb29wIGZvcmV2ZXI/IDUwMCBzZWVtcyBsaWtlIGFyZWFzb25hYmxlIGxpbWl0XHJcbiAgICBsZXQgcG9zID0gMDtcclxuICAgIGxldCByZXN1bHQgPSB0cnVlO1xyXG4gICAgd2hpbGUgKHBvcyA8PSBsaW0gJiYgcmVzdWx0ICE9IGZhbHNlKSB7XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgICAgcmVzdWx0ID0gZ2V0QmV0d2VlbigpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgLy9sb2coXCJiZXR3ZWVuW1wiK2krXCJdID0gXCIgKyByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgLy9sb2coXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbjogZ2V0U3RyaW5nc0JldHdlZW4oc3RyLHN0YXJ0LGVuZClcclxuICogQGRlc2M6IEdldHMgYWxsIHN0cmluZ3MgYmV0d2VlbiB0d28gb3RoZXIgc3RyaW5ncyAobXVsdGkgbWF0Y2gpXHJcbiAqIEBwYXJhbSBzdHJpbmcgc3RyOiBpbnB1dCBzdHJpbmcgdG8gY2hlY2tcclxuICogQHBhcmFtIHN0cmluZyBzdGFydDogc3RhcnQgc3RyaW5nIG1hcmtlclxyXG4gKiBAcGFyYW0gc3RyaW5nIGVuZDogZW5kIHN0cmluZyBtYXJrZXJcclxuICogQGxpbms6IGh0dHBzOi8vY29kZXBlbi5pby9BbGxGb3JUaGVDb2RlL3Blbi94eHh4eHh4XHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRDb3VudChzdHIpIHtcclxuICAgIHJldHVybiBzdHIuc3BsaXQoL1xcUysvKS5sZW5ndGggLSAxO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gaW5TdHJpbmcoZmluZCxzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5pbmRleE9mKGZpbmQpICE9PSAtMTsgfVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5TdHJpbmcoZmluZCxzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5pbmRleE9mKGZpbmQpICE9PSAtMTsgfVxuZXhwb3J0IGZ1bmN0aW9uIGxUcmltQnkoc3RyLCBieSkge1xyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoYnksIHN0ci5sZW5ndGgpO1xyXG59XG5leHBvcnQgZnVuY3Rpb24gcmVnRXhSZXBsYWNlQWxsKGhheXN0YWNrLCBuZWVkbGUsIHJlcCkge1xyXG4gICAgY29uc3Qgc3BlY2lhbCA9IFtcIi1cIiwgXCJbXCIsIFwiXVwiLCBcIi9cIiwgXCJ7XCIsIFwifVwiLCBcIihcIiwgXCIpXCIsIFwiKlwiLCBcIitcIiwgXCI/XCIsIFwiLlwiLCBcIlxcXFxcIiwgXCJeXCIsIFwiJFwiLCBcInxcIl07XHJcbiAgICBpZiAobmVlZGxlLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgaWYgKGlzSW5BcnJheShuZWVkbGUsIHNwZWNpYWwpKSB7XHJcbiAgICAgICAgICAgIG5lZWRsZSA9IFwiXFxcXFwiICsgbmVlZGxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHNlYXJjaFJlZ0V4cCA9IG5ldyBSZWdFeHAobmVlZGxlLCAnZycpO1xyXG4gICAgcmV0dXJuIGhheXN0YWNrLnJlcGxhY2Uoc2VhcmNoUmVnRXhwLCByZXApO1xyXG5cclxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUZpbGVGcm9tUGF0aChwYXRoKSB7XHJcbiAgICAvL2xldCBwYSA9ICcvdGhpcy9pcy9hL2ZvbGRlci9hRmlsZS50eHQnO1xyXG4gICAgbGV0IHIgPSAvW15cXC9dKiQvO1xyXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZShyLCAnJyk7XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VBbGwoaGF5c3RhY2ssbmVlZGxlLHJlcGxhY2Upe1xyXG4gICAgcmV0dXJuIGhheXN0YWNrLnNwbGl0KG5lZWRsZSkuam9pbihyZXBsYWNlKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VEb3VibGVCYWNrU2xhc2goc3RyLHJlcCl7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFxcXFxcL2csIHJlcCk7IC8vIHJlcGxhY2VzIGFsbCBvY2N1cmFuY2VzIG9mIFxcXFwgd2l0aCByZXBcclxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VEb3VibGVGb3J3YXJkU2xhc2goc3RyLHJlcCl7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcL1xcLy9nLCByZXApOyAvLyByZXBsYWNlcyBhbGwgb2NjdXJhbmNlcyBvZiAvLyB3aXRoIHJlcFxyXG59XG5leHBvcnQgZnVuY3Rpb24gclRyaW1CeShzdHIsIHRyaW1CeSkge1xyXG4gICAgcmV0dXJuIChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSB0cmltQnkpKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIHRyaW1TdHJpbmdCeShzdHIsIHRyaW1CeSkge1xyXG4gICAgcmV0dXJuIChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSB0cmltQnkpKTtcclxufVxuZXhwb3J0IGZ1bmN0aW9uIHVjRmlyc3Qocykge1xyXG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJykgcmV0dXJuICcnXHJcbiAgICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSlcclxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1haWwgKGVtYWlsKSB7XHJcbiAgICBsZXQgcmUgPSAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFxdKXwoKFthLXpBLVpcXC0wLTldK1xcLikrW2EtekEtWl17Mix9KSkkLztcclxuICAgIHJldHVybiByZS50ZXN0KGVtYWlsKTtcclxufVxyXG4iLCJpbXBvcnQgeyBhcmdzVG9PYmplY3QsIG9iamVjdFRvT2JqZWN0LCBsb2csIGdldEZpbGVFeHRlbnNpb24gIH0gZnJvbSBcIi4vbm9kZV9tb2R1bGVzL2FmdGMtbW9kdWxlcy9hZnRjLW1vZHVsZXMuanNcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQUZUQ1ByZWxvYWRlciB7ICBcclxuXHJcbiAgICBJdGVtVm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3JjID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5leHQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0b0F0dGFjaCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgWEhSTG9hZGVyID0gZnVuY3Rpb24gKHBhcmVudCwgdGhyZWFkSW5kZXgsIHF1ZXVlSW5kZXgsIHNyYykge1xyXG4gICAgICAgIC8vIGxvZyhcIlhIUkxvYWRlcihwYXJlbnQsIHRocmVhZEluZGV4LCBxdWV1ZUluZGV4LCBzcmMpXCIpO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMudGhyZWFkSW5kZXggPSB0aHJlYWRJbmRleDtcclxuICAgICAgICB0aGlzLnF1ZXVlSW5kZXggPSBxdWV1ZUluZGV4O1xyXG4gICAgICAgIHRoaXMuc3JjID0gc3JjO1xyXG5cclxuICAgICAgICB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHRoaXMueGhyLm9ubG9hZCA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub25Mb2FkSGFuZGxlcihlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKCkgPT4gdGhpcy51cGRhdGVIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgLy8gdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdHJhbnNmZXJDb21wbGV0ZSk7XHJcbiAgICAgICAgLy8gdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRyYW5zZmVyRmFpbGVkKTtcclxuICAgICAgICAvLyB0aGlzLnhoci5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdHJhbnNmZXJDYW5jZWxlZCk7XHJcbiAgICAgICAgLy8gRGV0ZWN0IGFib3J0LCBsb2FkLCBvciBlcnJvciB1c2luZyB0aGUgbG9hZGVuZCBldmVudFxyXG4gICAgICAgIC8vIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZW5kXCIsICgpID0+IHRoaXMubG9hZEVuZEhhbmRsZXIsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgdGhpcy54aHIub3BlbignR0VUJywgdGhpcy5zcmMsIHRydWUpO1xyXG4gICAgICAgIHRoaXMueGhyLnNlbmQoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXHJcblxyXG4gICAgICAgIHRoaXMub25Mb2FkSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIC8vIGxvZyhcIlhIUkxvYWRlci5vbkxvYWRIYW5kbGVyKCk6IFwiICsgdGhpcy5zcmMpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5vbkZpbGVMb2FkZWQodGhpcy50aHJlYWRJbmRleCwgdGhpcy5xdWV1ZUluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy54aHIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cclxuICAgIH1cclxuXHJcbiAgICAvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgbG9nKFwiQUZUQ1ByZWxvYWRlcigpXCIpO1xyXG5cclxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NIYW5kbGVyID0gXCJcIjtcclxuICAgICAgICB0aGlzLm9uQ29tcGxldGVIYW5kbGVyID0gXCJcIjtcclxuICAgIFxyXG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcclxuICAgICAgICB0aGlzLm5vT2ZGaWxlc1RvTG9hZCA9IDA7XHJcbiAgICBcclxuICAgICAgICB0aGlzLmpzb24gPSBmYWxzZTtcclxuICAgIFxyXG4gICAgICAgIHRoaXMubm9PZlRocmVhZHMgPSAzO1xyXG4gICAgICAgIHRoaXMudGhyZWFkID0gW107IC8vIFswXSA+IFtub09mVGhyZWFkc10gPSBcImF2YWlsYWJsZVwiIHx8IFwiZmlsbGVkXCJcclxuICAgIFxyXG4gICAgICAgIHRoaXMucXVldWVDb21wbGV0ZWQgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgICAgIHRoaXMudGltZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgYXJnc1RvT2JqZWN0KGFyZ3VtZW50cywgdGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0gfHwgZG9jdW1lbnQuYm9keTtcclxuICAgIH1cclxuICAgIC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXHJcblxyXG5cclxuICAgIGhlbHAoKSB7XHJcbiAgICAgICAgbGV0IG1zZyA9IFwiXCI7XHJcbiAgICAgICAgbXNnICs9IFwiQUZUQ1ByZWxvYWRlci5oZWxwKClcIiArIFwiXFxuXCI7XHJcbiAgICAgICAgbXNnICs9IFwiSlNPTjogWyB7c3JjOnBhdGgsYXV0b0F0dGFjaD10cnVlfSBdXCIgKyBcIlxcblwiO1xyXG4gICAgICAgIG1zZyArPSBcImF1dG9BdHRhY2ggaXMgb3B0aW9uYWwsIGRlZmF1bHRzIHRvIHRydWUsIG9ubHkgd29ya3MgZm9yIGNzcyBhbmQganMgZmlsZSBleHRlbnNpb25zXCIgKyBcIlxcblwiO1xyXG4gICAgICAgIGxvZyhtc2cpO1xyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cclxuXHJcblxyXG4gICAgYWRkKGlkLCBzcmMsIGF1dG9BdHRhY2ggPSB0cnVlKSB7XHJcbiAgICAgICAgLy8gbG9nKFwiQUZUQ1ByZWxvYWRlci5hZGQoaWQsc3JjLGF1dG9BdHRhY2g9dHJ1ZSlcIik7XHJcbiAgICAgICAgbGV0IGVudHJ5ID0gdGhpcy5JdGVtVm8oKTtcclxuICAgICAgICBlbnRyeS5pZCA9IGlkO1xyXG4gICAgICAgIGVudHJ5LnNyYyA9IHNyYztcclxuICAgICAgICBlbnRyeS5hdXRvQXR0YWNoID0gYXV0b0F0dGFjaDtcclxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZW50cnkpO1xyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cclxuXHJcbiAgICBzdGFydChqc29uUGF0aCkge1xyXG4gICAgICAgIGxvZyhcIkFGVENQcmVsb2FkZXIuc3RhcnQoKVwiKTtcclxuXHJcbiAgICAgICAgLy8gaW5pdFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ub09mVGhyZWFkczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhyZWFkW2ldID0gXCJhdmFpbGFibGVcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChqc29uUGF0aCkge1xyXG4gICAgICAgICAgICAvLyBVc2luZyBKU09OIGZpbGUgdG8gYWRkIGZpbGVzIHRvIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRDb25maWcoanNvblBhdGgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVzaW5nIGFkZCgpIHRvIGFkZCBmaWxlcyB0byB0aGUgcXVldWVcclxuICAgICAgICAgICAgdGhpcy5ub09mRmlsZXNUb0xvYWQgPSB0aGlzLnF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVGhyZWFkUG9vbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXHJcblxyXG5cclxuICAgIGxvYWRDb25maWcocGF0aCkge1xyXG4gICAgICAgIC8vIGxvZyhcIkFGVENQcmVsb2FkZXIubG9hZENvbmZpZyhwYXRoOlwiICsgcGF0aCArIFwiKVwiKTtcclxuXHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcclxuXHJcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0ICYmIHhoci5zdGF0dXMgPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmpzb24gPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9nKHRoaXMuanNvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmpzb24uZm9yRWFjaChqc29uRW50cnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2byA9IG5ldyB0aGlzLkl0ZW1WbygpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBvYmplY3RUb09iamVjdChqc29uRW50cnksIHZvLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICB2by5leHQgPSBnZXRGaWxlRXh0ZW5zaW9uKHZvLnNyYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHZvKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGxvZyh0aGlzLnF1ZXVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9PZkZpbGVzVG9Mb2FkID0gdGhpcy5xdWV1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUaHJlYWRQb29sKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gICAgXHJcblxyXG5cclxuXHJcblxyXG4gICAgcHJvY2Vzc1RocmVhZFBvb2woKSB7XHJcbiAgICAgICAgLy8gbG9nKFwiQUZUQ1ByZWxvYWRlci5wcm9jZXNzVGhyZWFkUG9vbCgpXCIpO1xyXG5cclxuICAgICAgICBsZXQgYWN0aXZlVGhyZWFkcyA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHRocmVhZEluZGV4ID0gMDsgdGhyZWFkSW5kZXggPCB0aGlzLm5vT2ZUaHJlYWRzOyB0aHJlYWRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRocmVhZFt0aHJlYWRJbmRleF0gPT09IFwiYXZhaWxhYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlc3RydWN0dXJlXHJcbiAgICAgICAgICAgICAgICBsZXQgcXVldWVJbmRleCwgaXRlbVZvO1xyXG4gICAgICAgICAgICAgICAgW3F1ZXVlSW5kZXgsIGl0ZW1Wb10gPSB0aGlzLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIC8vIGxvZyhpdGVtVm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1WbyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb2coXCJcXG4jIyMjIFRocmVhZCBbXCIrIHRocmVhZEluZGV4ICsgXCJdIC0tLS0tLS1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nKFwidGhyZWFkSW5kZXg6IFwiICsgdGhyZWFkSW5kZXggKyBcIiAgIHF1ZXVlSW5kZXg6IFwiICsgcXVldWVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nKGl0ZW1Wbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJlYWRbdGhyZWFkSW5kZXhdID0gXCJmaWxsZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtVm8ubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IHRoaXMuWEhSTG9hZGVyKHRoaXMsIHRocmVhZEluZGV4LCBxdWV1ZUluZGV4LCBpdGVtVm8uc3JjKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUaHJlYWRzKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGFsbCB0aHJlYWRzIGFyZSBpbmFjdGl2ZSB0aGVuIHdlIGFyZSBkb25lXHJcbiAgICAgICAgbGV0IHByZWxvYWRlckNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubm9PZlRocmVhZHM7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aHJlYWRbaV0gIT09IFwiYXZhaWxhYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIHByZWxvYWRlckNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcmVsb2FkZXJDb21wbGV0ZSkge1xyXG4gICAgICAgICAgICBsb2coXCJBRlRDUHJlbG9hZGVyKCk6IENvbXBsZXRlIVwiKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZUhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXHJcblxyXG4gICAgb25GaWxlTG9hZGVkKHRocmVhZEluZGV4LCBxdWV1ZUluZGV4KSB7XHJcbiAgICAgICAgLy8gbG9nKFwiQUZUQ1ByZWxvYWRlci5vbkZpbGVMb2FkZWQodGhyZWFkSW5kZXg6XCIrdGhyZWFkSW5kZXgrXCIscXVldWVJbmRleDpcIitxdWV1ZUluZGV4K1wiKVwiKTtcclxuICAgICAgICBsZXQgdm8gPSB0aGlzLnF1ZXVlW3F1ZXVlSW5kZXhdO1xyXG4gICAgICAgIHZvLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB2by5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudGhyZWFkW3RocmVhZEluZGV4XSA9IFwiYXZhaWxhYmxlXCI7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBhdHRhY2ggdG8gZG9tXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlW3F1ZXVlSW5kZXhdLmF1dG9BdHRhY2ggPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHZvLmV4dCA9PSBcImpzXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0dGFjaCBKUyB0byBET01cclxuICAgICAgICAgICAgICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICAgICAgICAgIC8vIHNjcmlwdC5vbmxvYWQgPSAoKT0+IHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlNjcmlwdCBhdHRhY2hlZCB0byBET006IFwiICsgdm8uc3JjKTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIHNjcmlwdC5zcmMgPSB2by5zcmM7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZvLmV4dCA9PSBcImNzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2ggQ1NTIHRvIERPTVxyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmsgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xyXG4gICAgICAgICAgICAgICAgbGluay5yZWwgID0gJ3N0eWxlc2hlZXQnO1xyXG4gICAgICAgICAgICAgICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcclxuICAgICAgICAgICAgICAgIGxpbmsuaHJlZiA9IHZvLnNyYztcclxuICAgICAgICAgICAgICAgIGxpbmsubWVkaWEgPSAnYWxsJztcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5hcHBlbmRDaGlsZCggbGluayApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5vblByb2dyZXNzSGFuZGxlcikge1xyXG4gICAgICAgICAgICBsZXQgcGVyY2VudCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBub09mRmlsZXNMb2FkZWQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmZvckVhY2godm8gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvLmxvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vT2ZGaWxlc0xvYWRlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgucm91bmQoKDEwMCAvIHRoaXMubm9PZkZpbGVzVG9Mb2FkKSAqIG5vT2ZGaWxlc0xvYWRlZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NIYW5kbGVyKHBlcmNlbnQsIHRoaXMucXVldWVbcXVldWVJbmRleF0uc3JjKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzVGhyZWFkUG9vbCgpO1xyXG4gICAgfVxyXG4gICAgLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cclxuXHJcbiAgICBnZXROZXh0KCkge1xyXG4gICAgICAgIGxldCBxdWV1ZUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGV0IGl0ZW1WbyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGVudHJ5ID0gdGhpcy5xdWV1ZVtpXTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5LmxvYWRlZCA9PT0gZmFsc2UgJiYgZW50cnkubG9hZGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgaXRlbVZvID0gZW50cnk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3F1ZXVlSW5kZXgsIGl0ZW1Wb107XHJcbiAgICB9XHJcbiAgICAvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxyXG5cclxufSIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgJiYgaXQgIT09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmcoaXQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZShudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgfVxufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcbiIsIi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSlcbiAgICA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsInZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG59IDogT2JqZWN0O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKHR5cGVvZiBzdG9yZS5pbnNwZWN0U291cmNlICE9ICdmdW5jdGlvbicpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG4iLCJ2YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgb2JqZWN0SGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVApIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiB0eXBlb2YgZGV0ZWN0aW9uID09ICdmdW5jdGlvbicgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaHRtbCcpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBkb2N1bWVudC5kb21haW4gJiYgbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpO1xuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgUHJvcGVydGllc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcblxudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICBzZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQ7XG4gICAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICB2YXIgc3RhdGU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuICAgIH1cbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICBpZiAoIXN0YXRlLnNvdXJjZSkge1xuICAgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuICAgIH1cbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuIiwiLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWwsIGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcbiIsInZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjcuMCcsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcbiIsIi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG4iLCJ2YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuIiwidmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICYmICFTeW1ib2wuc2hhbVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSkge1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhcyhTeW1ib2wsIG5hbWUpKSBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2xbbmFtZV07XG4gICAgZWxzZSBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IG1vZHVsZVsnZGVmYXVsdCddIDpcblx0XHQoKSA9PiBtb2R1bGU7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApIiwiaW1wb3J0IHtsb2csIHNldEhUTUx9IGZyb20gXCJhZnRjLW1vZHVsZXNcIjtcclxuaW1wb3J0IHsgQUZUQ1ByZWxvYWRlciB9IGZyb20gXCIuLi9hZnRjLnByZWxvYWRlclwiO1xyXG5cclxuY29uc3QgcHJlbG9hZGVyID0gbmV3IEFGVENQcmVsb2FkZXIoe1xyXG4gICAgb25Qcm9ncmVzc0hhbmRsZXI6IG9uUHJvZ3Jlc3NIYW5kbGVyLFxyXG4gICAgb25Db21wbGV0ZUhhbmRsZXI6IG9uQ29tcGxldGVIYW5kbGVyXHJcbn0pO1xyXG5cclxucHJlbG9hZGVyLmhlbHAoKTtcclxuXHJcbnByZWxvYWRlci5zdGFydChcIi4vcHJlbG9hZGVyLmpzb25cIik7XHJcblxyXG5mdW5jdGlvbiBvblByb2dyZXNzSGFuZGxlcihwLGZpbGUpIHtcclxuICAgIHNldEhUTUwoXCJzdGF0dXNcIixcIkxvYWRpbmdcIik7XHJcbiAgICBzZXRIVE1MKFwicGVyY2VudFwiLHAgKyBcIiVcIik7XHJcbiAgICBzZXRIVE1MKFwiZmlsZXNcIixmaWxlLFwicHJlcGVuZFwiKTtcclxuICAgIC8vIGxvZyhcIm9uUHJvZ3Jlc3NIYW5kbGVyKHA6XCIgKyBwICsgXCIpXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNvbXBsZXRlSGFuZGxlcigpIHtcclxuICAgIHNldEhUTUwoXCJzdGF0dXNcIixcIkxvYWRlZFwiKTtcclxuICAgIC8vIGxvZyhcIm9uQ29tcGxldGVIYW5kbGVyKClcIik7XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9